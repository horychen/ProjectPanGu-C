#include <All_Definition.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// 假设数据点数量已知
#define HIP_SHANK_N 106
REAL HIP_SHANK_FREQUENCY = 0.0001;  // kHz = 1 ms

#define HIP_TYPE 0
#define SHANK_TYPE 1

#define HIP_MIN 0.04
#define HIP_MAX -0.8 // 为什么这个是负的？而且MAX比MIN小？
#define CAN01_MIN 48000		//51943
#define CAN01_MAX 62000		//61584

#define SHANK_MIN -0.8855
#define SHANK_MAX 0.25
#define CAN03_MIN 30400
#define CAN03_MAX 51818

#define CAN_QMAX 131072

// 用于存储数据的结构体
typedef struct {
    double hip[HIP_SHANK_N];
    double shank[HIP_SHANK_N];
} HIP_SHANK_ANGLE_TABLE;


#pragma DATA_SECTION(hip_shank_angle_table,"MYTABLE_3");
HIP_SHANK_ANGLE_TABLE hip_shank_angle_table = {
    .hip = {0.040295454579787664,0.03948415763562727,0.022866482453853275,0.006205019353828244,-0.02261456856680697,-0.0528293160508345,-0.08208572841345071,-0.10969297382891527,-0.13551526996115024,-0.1595748833929039,-0.18195729217082332,-0.20277138862990815,-0.22212985277180683,-0.24013962870197067,-0.25689780976312904,-0.27249040801749047,-0.2869926059398794,-0.3004697083929059,-0.31297836388592615,-0.32456782472322054,-0.33528113036067364,-0.34515616316901554,-0.3542265615353123,-0.3625224939329287,-0.3700713064397264,-0.3768980594771546,-0.38302596983950477,-0.38847677289347715,-0.3932710180248834,-0.39742830847387467,-0.40096749488131966,-0.40390683027706065,-0.40626409290776533,-0.40805668221772085,-0.4093016924296081,-0.4100159674863316,-0.41021614057126066,-0.40991866098859986,-0.40913981082900197,-0.4078957135448985,-0.4062023362980053,-0.404075487705507,-0.4015308123936658,-0.39858378356308255,-0.39524969457675696,-0.3915436503999282,-0.3874805595504956,-0.38307512706181734,-0.3783418488175079,-0.373295007491729,-0.3679486702191735,-0.3623166880268721,-0.3564126969848078,-0.350250120973307,-0.3438421759211346,-0.3372018753376144,-0.33034203694322445,-0.3232752901940968,-0.31601408449497936,-0.3085706979007032,-0.300957246116405,-0.2931856916204585,-0.2852678527498148,-0.277215412604497,-0.26903992764534435,-0.2607528358762381,-0.2523654645185027,-0.24388903710060975,-0.235334679900578,-0.22671342769139327,-0.21803622875141399,-0.2093139491120121,-0.20055737602378254,-0.19177722063054561,-0.18298411984722127,-0.17418863744355031,-0.16540126434070787,-0.15663241813217768,-0.14789244184395284,-0.13919160195234323,-0.13054008568032188,-0.12194799759577618,-0.11342535553701215,-0.10498208589269889,-0.09662801826507383,-0.08837287954666459,-0.08022628744217607,-0.07219774346849073,-0.06429662546692187,-0.04732652888335151,-0.0379992970939838,-0.03084029152341164,-0.024637060858658497,-0.01779622532953743,-0.011948208334833527,-0.005689217619607485,0.0002857661664057414,0.00614514921078128,0.011908487430616784,0.017564451605226787,0.023087017963770988,0.028446970568217184,0.03361773669147538,0.038577325229814066,0.04331027728699151,0.040295454579787664},
    .shank = {-0.885519616918762,-0.8855502902086003,-0.8400092758027017,-0.8080857612879758,-0.7512062062591479,-0.691208741354794,-0.634556155394053,-0.5824633671508231,-0.5344950263367557,-0.49019106721508954,-0.4491772474919891,-0.41114990438416116,-0.37585799191076735,-0.3430902017015322,-0.31266591849537545,-0.2844287381996179,-0.2582417140728574,-0.23398379417171059,-0.2115470979199136,-0.1908347958339861,-0.17175943115418757,-0.1542415711598147,-0.13820870869490653,-0.12359435665346262,-0.11033729348500598,-0.09838092849096669,-0.08767276328843758,-0.07816393130468254,-0.06980880118654118,-0.0625646330018786,-0.05639127837170885,-0.05125091740503297,-0.04710782665410579,-0.043928173364955934,-0.041679832136661016,-0.04033222077441519,-0.039856152663086286,-0.04022370342788158,-0.04140809000808883,-0.04338356056492572,-0.0461252938879186,-0.0496093071659109,-0.05381237115664313,-0.05871193192902986,-0.06428603847006205,-0.07051327554754057,-0.07737270130420022,-0.08484378913078335,-0.09290637342760384,-0.10154059891796959,-0.11072687322389037,-0.12044582245619502,-0.13067824960826277,-0.14140509557602707,-0.15260740265715464,-0.1642662804098711,-0.17636287377714696,-0.18887833340503965,-0.20179378810507417,-0.21509031942977705,-0.22874893834785512,-0.24275056402099723,-0.257076004697897,-0.2717059407528108,-0.286620909905608,-0.3018012946679233,-0.3172273120654154,-0.3328790056894048,-0.3487362401320306,-0.36477869785764233,-0.3809858785592663,-0.39733710104272574,-0.4138115076723052,-0.4303880714007848,-0.4470456053933793,-0.46376277523961223,-0.4805181137297529,-0.49729003815323053,-0.5140568700558783,-0.5307968573710478,-0.5474881988171953,-0.5641090704317506,-0.5806376540884266,-0.5970521678231651,-0.6133308977730707,-0.6294522315135567,-0.6453946925619427,-0.6611369758014052,-0.6766579835680331,-0.7170714339555071,-0.7283929334760704,-0.7387860435884301,-0.7498403182934796,-0.7631348534707103,-0.7746223872781368,-0.7868141818928838,-0.7985512019024041,-0.8101858777524751,-0.8216503052714643,-0.83287319706123,-0.8437938456740783,-0.8543637117335205,-0.8645440310528507,-0.8743034646592742,-0.8836275734954298,-0.885519616918762}
};

double linearInterpolate(double x, double x1, double x2, double y1, double y2) {
    return y1 + (x - x1) * (y2 - y1) / (x2 - x1);
}


// type: 0 for hip, 1 for shank
double look_up_hip_shank_angle(double t, int type) {
    double x;
    int x1, x2;

    // x = t / HIP_SHANK_TIME_INTERVAL; // TODO：这个除法很不经济，改成乘法
    x = t * HIP_SHANK_FREQUENCY;
    while (x < 0)
    {
        x += (HIP_SHANK_N-1);
    }
    while (x > (HIP_SHANK_N-1))
    {
        x -= (HIP_SHANK_N-1);
    }
    x1 = (int)floor(x);
    x2 = x1 + 1;

    if (type == HIP_TYPE) {
        return linearInterpolate(x, x1, x2, hip_shank_angle_table.hip[x1], hip_shank_angle_table.hip[x2]);
    } else {
        return linearInterpolate(x, x1, x2, hip_shank_angle_table.shank[x1], hip_shank_angle_table.shank[x2]);
    }
}


double hip_shank_angle_to_can(double angle, int type) {
    if (type == HIP_TYPE)
    {
        return linearInterpolate(angle, HIP_MIN, HIP_MAX, CAN01_MIN, CAN01_MAX);
    }
    else
    {
        return linearInterpolate(angle, SHANK_MIN, SHANK_MAX, CAN03_MIN, CAN03_MAX);
    }
}



//st_axis *list_pointer_to_Axes[NUMBER_OF_AXES];
st_axis Axis_1;
st_axis *Axis;
int axisCnt = 0;
double target_tick = 0.0;

// ====为了同时运行两台电机，增加的另一份控制结构体
#if NUMBER_OF_AXES == 2

    st_axis Axis_2;


    #define get_Axis_CTRL_pointers \
        if (axisCnt == 0)          \
        {                          \
            Axis = &Axis_1;        \
            CTRL = &CTRL_1;        \
        }                          \
        if (axisCnt == 1)          \
        {                          \
            Axis = &Axis_2;        \
            CTRL = &CTRL_2;        \
        }

    // =======增加结束
#else
    // do nothing here (use same codes as simulation)

    void get_Axis_CTRL_pointers(int axisCnt, st_axis *pAxis, struct ControllerForExperiment *pCTRL){
        //if(axisCnt == 0)
        {
            pAxis = &Axis_1;
            pCTRL = &CTRL_1;
        }
    }

#endif


Uint32 position_count_SCI_shank_fromCPU2;
Uint32 position_count_SCI_hip_fromCPU2;
Uint32 position_count_SCI_fromCPU2;
Uint32 position_count_CAN_ID0x01_fromCPU2;
Uint32 position_count_CAN_ID0x03_fromCPU2;
Uint32 position_count_CAN_fromCPU2;
Uint32 CPU2_commu_error_counter = 0;



REAL deg_four_bar_map_motor_encoder_angle;
REAL rad_four_bar_map_motor_encoder_angle = 0;
int32 cnt_four_bar_map_motor_encoder_angle = 0;
#if FALSE // 朱俊磊四连杆解算代码 LOOK Up TABLE: input is CAN encoder read, and output is 485 encoder read.
    // 假设数据点数量已知
    #define LUT_LENGTH 1949

    // 用于存储数据的结构体
    typedef struct {
        REAL input[LUT_LENGTH];
        REAL output[LUT_LENGTH];
    } DataTable;

    DataTable ZJL_table = {
        .input = {185.358582,185.325623,185.29541,185.262451,185.232239,185.202026,185.171814,185.138855,185.108643,185.07843,185.048218,185.015259,184.9823,184.952087,184.921875,184.888916,184.858704,184.828491,184.798279,184.768066,184.737854,184.707642,184.677429,184.647217,184.617004,184.586792,184.55658,184.526367,184.493408,184.463196,184.430237,184.400024,184.369812,184.336853,184.306641,184.276428,184.246216,184.216003,184.185791,184.155579,184.125366,184.095154,184.064941,184.034729,184.004517,183.974304,183.944092,183.913879,183.883667,183.853455,183.823242,183.79303,183.762817,183.732605,183.702393,183.67218,183.641968,183.611755,183.581543,183.548584,183.518372,183.485413,183.4552,183.424988,183.394775,183.364563,183.334351,183.304138,183.271179,183.240967,183.210754,183.177795,183.147583,183.117371,183.087158,183.056946,183.026733,182.996521,182.966309,182.936096,182.905884,182.875671,182.842712,182.8125,182.779541,182.746582,182.71637,182.686157,182.655945,182.622986,182.590027,182.559814,182.529602,182.49939,182.469177,182.438965,182.408752,182.375793,182.345581,182.315369,182.285156,182.252197,182.221985,182.191772,182.16156,182.131348,182.101135,182.070923,182.04071,182.010498,181.977539,181.947327,181.917114,181.886902,181.856689,181.82373,181.790771,181.760559,181.730347,181.697388,181.667175,181.636963,181.604004,181.573792,181.540833,181.51062,181.480408,181.450195,181.419983,181.389771,181.359558,181.329346,181.299133,181.268921,181.238708,181.208496,181.178284,181.148071,181.117859,181.087646,181.057434,181.027222,180.997009,180.966797,180.936584,180.906372,180.873413,180.843201,180.812988,180.782776,180.752563,180.722351,180.689392,180.65918,180.626221,180.596008,180.565796,180.535583,180.505371,180.475159,180.4422,180.411987,180.381775,180.351562,180.318604,180.288391,180.255432,180.22522,180.195007,180.164795,180.134583,180.10437,180.074158,180.043945,180.013733,179.983521,179.950562,179.920349,179.890137,179.857178,179.826965,179.794006,179.763794,179.730835,179.700623,179.667664,179.637451,179.607239,179.577026,179.544067,179.513855,179.483643,179.45343,179.423218,179.393005,179.362793,179.329834,179.299622,179.269409,179.239197,179.208984,179.176025,179.145813,179.115601,179.085388,179.055176,179.024963,178.994751,178.964539,178.93158,178.901367,178.871155,178.840942,178.81073,178.780518,178.747559,178.717346,178.687134,178.656921,178.626709,178.596497,178.566284,178.536072,178.505859,178.4729,178.442688,178.412476,178.379517,178.349304,178.316345,178.286133,178.253174,178.222961,178.190002,178.157043,178.126831,178.096619,178.066406,178.036194,178.005981,177.975769,177.94281,177.912598,177.882385,177.849426,177.819214,177.789001,177.758789,177.728577,177.698364,177.665405,177.635193,177.60498,177.574768,177.541809,177.511597,177.478638,177.448425,177.418213,177.388,177.357788,177.324829,177.294617,177.264404,177.234192,177.203979,177.171021,177.140808,177.110596,177.080383,177.050171,177.019958,176.987,176.956787,176.926575,176.896362,176.86615,176.835938,176.805725,176.775513,176.7453,176.715088,176.682129,176.651917,176.621704,176.591492,176.555786,176.525574,176.495361,176.465149,176.434937,176.401978,176.366272,176.33606,176.305847,176.272888,176.242676,176.212463,176.182251,176.152039,176.121826,176.091614,176.061401,176.031189,176.000977,175.970764,175.940552,175.910339,175.880127,175.849915,175.816956,175.783997,175.753784,175.723572,175.690613,175.6604,175.627441,175.594482,175.56427,175.534058,175.501099,175.46814,175.435181,175.404968,175.374756,175.344543,175.314331,175.284119,175.253906,175.220947,175.190735,175.160522,175.13031,175.100098,175.069885,175.036926,175.006714,174.976501,174.946289,174.916077,174.885864,174.852905,174.822693,174.79248,174.762268,174.732056,174.701843,174.671631,174.638672,174.608459,174.578247,174.548035,174.517822,174.48761,174.457397,174.427185,174.396973,174.364014,174.333801,174.303589,174.273376,174.243164,174.212952,174.182739,174.152527,174.122314,174.089355,174.059143,174.028931,173.998718,173.968506,173.938293,173.905334,173.875122,173.84491,173.814697,173.784485,173.754272,173.721313,173.691101,173.660889,173.630676,173.600464,173.570251,173.537292,173.50708,173.476868,173.443909,173.413696,173.380737,173.350525,173.320312,173.287354,173.257141,173.226929,173.196716,173.166504,173.136292,173.106079,173.075867,173.045654,173.015442,172.985229,172.952271,172.922058,172.891846,172.861633,172.828674,172.798462,172.76825,172.738037,172.707825,172.674866,172.644653,172.611694,172.581482,172.55127,172.518311,172.488098,172.457886,172.427673,172.394714,172.361755,172.331543,172.301331,172.271118,172.240906,172.210693,172.180481,172.150269,172.120056,172.089844,172.059631,172.029419,171.999207,171.966248,171.936035,171.905823,171.87561,171.845398,171.815186,171.784973,171.752014,171.721802,171.691589,171.661377,171.631165,171.600952,171.57074,171.540527,171.510315,171.477356,171.447144,171.414185,171.383972,171.351013,171.320801,171.287842,171.257629,171.227417,171.197205,171.161499,171.131287,171.101074,171.070862,171.040649,171.010437,170.980225,170.950012,170.917053,170.886841,170.856628,170.826416,170.796204,170.765991,170.735779,170.705566,170.675354,170.645142,170.614929,170.584717,170.551758,170.518799,170.488586,170.455627,170.425415,170.392456,170.359497,170.329285,170.299072,170.26886,170.238647,170.208435,170.175476,170.142517,170.112305,170.079346,170.049133,170.018921,169.988708,169.958496,169.928284,169.898071,169.867859,169.837646,169.807434,169.777222,169.744263,169.71405,169.683838,169.653625,169.620667,169.590454,169.560242,169.527283,169.49707,169.466858,169.433899,169.403687,169.373474,169.343262,169.313049,169.28009,169.247131,169.216919,169.186707,169.156494,169.126282,169.096069,169.065857,169.035645,169.005432,168.97522,168.945007,168.914795,168.884583,168.85437,168.824158,168.793945,168.763733,168.733521,168.703308,168.673096,168.640137,168.609924,168.579712,168.5495,168.519287,168.489075,168.458862,168.42865,168.398438,168.368225,168.335266,168.305054,168.274841,168.244629,168.214417,168.181458,168.148499,168.118286,168.085327,168.052368,168.022156,167.991943,167.961731,167.931519,167.901306,167.871094,167.840881,167.810669,167.780457,167.747498,167.714539,167.684326,167.654114,167.623901,167.593689,167.563477,167.533264,167.503052,167.470093,167.43988,167.409668,167.379456,167.346497,167.316284,167.286072,167.255859,167.225647,167.195435,167.165222,167.132263,167.102051,167.071838,167.038879,167.008667,166.975708,166.945496,166.915283,166.885071,166.854858,166.824646,166.794434,166.764221,166.734009,166.698303,166.668091,166.637878,166.607666,166.577454,166.547241,166.511536,166.478577,166.448364,166.418152,166.387939,166.357727,166.324768,166.294556,166.261597,166.231384,166.198425,166.168213,166.138,166.107788,166.077576,166.047363,166.017151,165.986938,165.956726,165.926514,165.893555,165.863342,165.83313,165.802917,165.772705,165.742493,165.71228,165.679321,165.646362,165.61615,165.585938,165.555725,165.525513,165.4953,165.465088,165.434875,165.401917,165.368958,165.338745,165.308533,165.27832,165.245361,165.212402,165.18219,165.151978,165.116272,165.08606,165.055847,165.025635,164.992676,164.962463,164.929504,164.899292,164.86908,164.838867,164.805908,164.775696,164.745483,164.715271,164.685059,164.6521,164.621887,164.588928,164.558716,164.528503,164.495544,164.465332,164.43512,164.404907,164.374695,164.341736,164.311523,164.281311,164.251099,164.21814,164.187927,164.157715,164.127502,164.09729,164.067078,164.036865,164.006653,163.97644,163.943481,163.913269,163.883057,163.852844,163.822632,163.792419,163.762207,163.729248,163.699036,163.666077,163.635864,163.605652,163.575439,163.54248,163.512268,163.482056,163.451843,163.421631,163.388672,163.358459,163.328247,163.298035,163.265076,163.234863,163.201904,163.171692,163.141479,163.111267,163.078308,163.048096,163.017883,162.987671,162.957458,162.927246,162.897034,162.864075,162.831116,162.800903,162.770691,162.740479,162.710266,162.680054,162.649841,162.619629,162.589417,162.556458,162.526245,162.496033,162.463074,162.432861,162.399902,162.366943,162.336731,162.306519,162.276306,162.243347,162.213135,162.182922,162.15271,162.122498,162.092285,162.059326,162.029114,161.998901,161.965942,161.93573,161.902771,161.869812,161.8396,161.809387,161.779175,161.748962,161.71875,161.688538,161.658325,161.628113,161.5979,161.567688,161.534729,161.504517,161.474304,161.441345,161.411133,161.38092,161.347961,161.317749,161.287537,161.257324,161.227112,161.196899,161.166687,161.133728,161.103516,161.073303,161.043091,161.012878,160.979919,160.949707,160.919495,160.889282,160.85907,160.828857,160.798645,160.768433,160.73822,160.705261,160.672302,160.64209,160.611877,160.578918,160.548706,160.518494,160.488281,160.455322,160.42511,160.394897,160.364685,160.331726,160.298767,160.265808,160.235596,160.205383,160.172424,160.142212,160.112,160.079041,160.048828,160.015869,159.985657,159.955444,159.922485,159.892273,159.862061,159.831848,159.798889,159.76593,159.735718,159.705505,159.672546,159.642334,159.609375,159.579163,159.54895,159.518738,159.488525,159.455566,159.422607,159.389648,159.359436,159.326477,159.296265,159.266052,159.23584,159.205627,159.175415,159.145203,159.11499,159.084778,159.054565,159.021606,158.991394,158.958435,158.928223,158.895264,158.865051,158.832092,158.80188,158.771667,158.741455,158.711243,158.68103,158.650818,158.617859,158.587646,158.557434,158.527222,158.497009,158.46405,158.433838,158.403625,158.373413,158.343201,158.312988,158.280029,158.249817,158.219604,158.186646,158.153687,158.123474,158.090515,158.060303,158.027344,157.997131,157.964172,157.93396,157.903748,157.868042,157.835083,157.804871,157.771912,157.738953,157.70874,157.678528,157.645569,157.615356,157.579651,157.549438,157.519226,157.486267,157.456055,157.425842,157.39563,157.365417,157.335205,157.302246,157.272034,157.241821,157.211609,157.17865,157.148438,157.118225,157.085266,157.052307,157.019348,156.986389,156.956177,156.925964,156.895752,156.86554,156.835327,156.805115,156.774902,156.741943,156.711731,156.681519,156.651306,156.618347,156.588135,156.557922,156.52771,156.497498,156.467285,156.434326,156.404114,156.371155,156.340942,156.31073,156.280518,156.247559,156.217346,156.187134,156.156921,156.126709,156.09375,156.063538,156.033325,156.000366,155.970154,155.939941,155.909729,155.879517,155.849304,155.819092,155.788879,155.758667,155.728455,155.698242,155.66803,155.637817,155.604858,155.571899,155.541687,155.508728,155.475769,155.44281,155.412598,155.379639,155.349426,155.316467,155.286255,155.256042,155.22583,155.195618,155.165405,155.135193,155.10498,155.074768,155.044556,155.011597,154.981384,154.951172,154.920959,154.890747,154.860535,154.827576,154.797363,154.767151,154.736938,154.706726,154.676514,154.646301,154.616089,154.58313,154.552917,154.519958,154.489746,154.459534,154.429321,154.399109,154.368896,154.338684,154.308472,154.278259,154.2453,154.215088,154.184875,154.154663,154.124451,154.094238,154.064026,154.031067,154.000854,153.970642,153.94043,153.910217,153.880005,153.849792,153.81958,153.786621,153.756409,153.72345,153.693237,153.660278,153.630066,153.599854,153.569641,153.536682,153.50647,153.476257,153.446045,153.415833,153.38562,153.355408,153.325195,153.294983,153.264771,153.231812,153.201599,153.171387,153.141174,153.108215,153.078003,153.045044,153.012085,152.981873,152.95166,152.918701,152.885742,152.85553,152.825317,152.795105,152.764893,152.73468,152.701721,152.671509,152.641296,152.611084,152.580872,152.550659,152.5177,152.487488,152.457275,152.424316,152.394104,152.363892,152.330933,152.30072,152.267761,152.234802,152.201843,152.171631,152.141418,152.111206,152.078247,152.045288,152.012329,151.97937,151.946411,151.916199,151.885986,151.855774,151.825562,151.792603,151.76239,151.729431,151.699219,151.669006,151.638794,151.605835,151.575623,151.54541,151.512451,151.482239,151.44928,151.416321,151.386108,151.355896,151.325684,151.295471,151.265259,151.2323,151.202087,151.171875,151.141663,151.108704,151.078491,151.048279,151.018066,150.987854,150.957642,150.927429,150.897217,150.867004,150.834045,150.801086,150.770874,150.740662,150.710449,150.680237,150.647278,150.614319,150.58136,150.551147,150.518188,150.487976,150.457764,150.427551,150.397339,150.367126,150.334167,150.303955,150.273743,150.240784,150.210571,150.180359,150.1474,150.117188,150.086975,150.056763,150.02655,149.993591,149.960632,149.93042,149.900208,149.869995,149.83429,149.804077,149.773865,149.743652,149.71344,149.683228,149.653015,149.622803,149.59259,149.559631,149.529419,149.499207,149.468994,149.438782,149.408569,149.37561,149.342651,149.312439,149.282227,149.252014,149.221802,149.188843,149.15863,149.128418,149.098206,149.067993,149.035034,149.004822,148.974609,148.944397,148.914185,148.883972,148.851013,148.820801,148.790588,148.757629,148.727417,148.697205,148.666992,148.63678,148.606567,148.576355,148.546143,148.51593,148.485718,148.452759,148.422546,148.389587,148.359375,148.326416,148.296204,148.265991,148.233032,148.20282,148.172607,148.142395,148.112183,148.08197,148.049011,148.018799,147.988586,147.958374,147.928162,147.897949,147.867737,147.837524,147.807312,147.774353,147.744141,147.713928,147.683716,147.653503,147.623291,147.593079,147.562866,147.532654,147.499695,147.469482,147.43927,147.409058,147.378845,147.348633,147.31842,147.288208,147.257996,147.227783,147.197571,147.167358,147.137146,147.106934,147.073975,147.043762,147.01355,146.983337,146.950378,146.917419,146.887207,146.854248,146.824036,146.793823,146.760864,146.730652,146.700439,146.670227,146.637268,146.607056,146.574097,146.543884,146.513672,146.480713,146.447754,146.417542,146.384583,146.35437,146.321411,146.291199,146.260986,146.230774,146.197815,146.167603,146.13739,146.107178,146.074219,146.044006,146.011047,145.980835,145.950623,145.917664,145.887451,145.857239,145.827026,145.796814,145.763855,145.730896,145.700684,145.670471,145.640259,145.610046,145.579834,145.546875,145.516663,145.483704,145.453491,145.423279,145.393066,145.362854,145.332642,145.299683,145.26947,145.236511,145.206299,145.176086,145.143127,145.112915,145.082703,145.05249,145.019531,144.989319,144.959106,144.928894,144.898682,144.868469,144.838257,144.808044,144.775085,144.742126,144.711914,144.678955,144.648743,144.61853,144.588318,144.558105,144.527893,144.494934,144.464722,144.434509,144.404297,144.371338,144.341125,144.308167,144.277954,144.247742,144.217529,144.187317,144.154358,144.124146,144.091187,144.058228,144.028015,143.995056,143.964844,143.931885,143.898926,143.865967,143.835754,143.805542,143.77533,143.745117,143.714905,143.684692,143.65448,143.624268,143.594055,143.563843,143.53363,143.503418,143.470459,143.440247,143.410034,143.379822,143.346863,143.31665,143.283691,143.253479,143.223267,143.193054,143.162842,143.129883,143.096924,143.066711,143.033752,143.00354,142.973328,142.943115,142.910156,142.879944,142.846985,142.816772,142.78656,142.756348,142.726135,142.695923,142.662964,142.632751,142.602539,142.572327,142.542114,142.511902,142.481689,142.451477,142.418518,142.388306,142.355347,142.325134,142.289429,142.259216,142.229004,142.196045,142.163086,142.132874,142.099915,142.069702,142.03949,142.009277,141.979065,141.946106,141.915894,141.885681,141.855469,141.82251,141.789551,141.759338,141.729126,141.698914,141.668701,141.635742,141.60553,141.575317,141.545105,141.512146,141.479187,141.446228,141.416016,141.38031,141.350098,141.317139,141.286926,141.251221,141.221008,141.188049,141.157837,141.127625,141.094666,141.064453,141.034241,141.001282,140.968323,140.93811,140.907898,140.877686,140.847473,140.817261,140.787048,140.756836,140.726624,140.693665,140.663452,140.63324,140.603027,140.572815,140.542603,140.509644,140.479431,140.449219,140.419006,140.388794,140.358582,140.325623,140.29541,140.265198,140.234985,140.204773,140.171814,140.141602,140.111389,140.081177,140.048218,140.015259,139.9823,139.952087,139.919128,139.888916,139.858704,139.828491,139.798279,139.768066,139.737854,139.707642,139.677429,139.647217,139.617004,139.586792,139.55658,139.523621,139.490662,139.460449,139.42749,139.397278,139.367065,139.336853,139.306641,139.276428,139.246216,139.216003,139.185791,139.155579,139.12262,139.092407,139.062195,139.031982,138.999023,138.968811,138.938599,138.908386,138.875427,138.845215,138.812256,138.782043,138.751831,138.721619,138.68866,138.658447,138.625488,138.595276,138.565063,138.534851,138.501892,138.47168,138.441467,138.408508,138.378296,138.348083,138.317871,138.287659,138.257446,138.227234,138.194275,138.164062,138.13385,138.103638,138.073425,138.040466,138.010254,137.980042,137.947083,137.914124,137.883911,137.853699,137.823486,137.793274,137.763062,137.730103,137.69989,137.666931,137.636719,137.60376,137.573547,137.543335,137.513123,137.48291,137.452698,137.422485,137.389526,137.356567,137.326355,137.296143,137.263184,137.232971,137.202759,137.1698,137.139587,137.109375,137.079163,137.04895,137.018738,136.988525,136.955566,136.925354,136.892395,136.862183,136.829224,136.799011,136.768799,136.738586,136.708374,136.678162,136.647949,136.617737,136.584778,136.554565,136.524353,136.491394,136.458435,136.428223,136.39801,136.367798,136.334839,136.304626,136.274414,136.244202,136.211243,136.18103,136.145325,136.115112,136.0849,136.051941,136.021729,135.991516,135.961304,135.931091,135.898132,135.86792,135.837708,135.807495,135.77179,135.738831,135.708618,135.678406,135.648193,135.617981,135.587769,135.557556,135.527344,135.497131,135.464172,135.431213,135.398254,135.368042,135.33783,135.307617,135.277405,135.247192,135.21698,135.184021,135.153809,135.12085,135.090637,135.057678,135.027466,134.997253,134.967041,134.936829,134.90387,134.873657,134.840698,134.807739,134.777527,134.747314,134.717102,134.68689,134.656677,134.626465,134.596252,134.563293,134.533081,134.502869,134.472656,134.442444,134.409485,134.379272,134.346313,134.316101,134.285889,134.25293,134.222717,134.189758,134.159546,134.126587,134.096375,134.063416,134.033203,134.002991,133.972778,133.942566,133.912354,133.879395,133.849182,133.81897,133.788757,133.758545,133.728333,133.69812,133.667908,133.634949,133.60199,133.571777,133.538818,133.508606,133.475647,133.445435,133.415222,133.38501,133.352051,133.319092,133.288879,133.258667,133.228455,133.195496,133.165283,133.135071,133.104858,133.071899,133.03894,133.008728,132.978516,132.948303,132.915344,132.882385,132.852173,132.819214,132.789001,132.758789,132.728577,132.698364,132.665405,132.632446,132.602234,132.572021,132.541809,132.511597,132.481384,132.451172,132.420959,132.390747,132.357788,132.327576,132.297363,132.267151,132.236938,132.206726,132.173767,132.143555,132.110596,132.080383,132.050171,132.019958,131.989746,131.956787,131.926575,131.896362,131.86615,131.835938,131.805725,131.775513,131.7453,131.715088,131.684875,131.651917,131.618958,131.585999,131.555786,131.525574,131.492615,131.459656,131.429443,131.396484,131.363525,131.333313,131.303101,131.270142,131.237183,131.204224,131.174011,131.143799,131.113586,131.083374,131.053162,131.022949,130.992737,130.962524,130.932312,130.9021,130.871887,130.841675,130.811462,130.78125,130.748291,130.715332,130.682373,130.652161,130.619202,130.588989,130.558777,130.528564,130.498352,130.46814,130.435181,130.399475,130.366516,130.333557,130.303345,130.273132,130.240173,130.207214,130.177002,130.14679,130.116577,130.083618,130.050659,130.020447,129.987488,129.957275,129.924316,129.894104,129.863892,129.833679,129.80072,129.767761,129.732056,129.701843,129.671631,129.638672,129.608459,129.578247,129.545288,129.515076,129.484863,129.454651,129.424438,129.391479,129.361267,129.331055,129.300842,129.27063,129.240417,129.210205,129.179993,129.144287,129.114075,129.083862,129.05365,129.023438,128.987732,128.95752,128.924561,128.894348,128.861389,128.831177,128.800964,128.770752,128.74054,128.707581,128.674622,128.644409,128.614197,128.583984,128.553772,128.52356,128.493347,128.460388,128.427429,128.397217,128.364258,128.331299,128.301086,128.268127,128.237915,128.204956,128.174744,128.144531,128.114319,128.08136,128.051147,128.020935,127.985229,127.952271,127.922058,127.891846,127.858887,127.825928,127.792969,127.762756,127.732544,127.702332,127.672119,127.63916,127.608948,127.578735,127.548523,127.515564,127.485352,127.455139,127.424927,127.394714,127.364502,127.331543,127.301331,127.271118,127.238159,127.207947,127.174988,127.144775,127.111816,127.081604,127.048645,127.015686,126.982727,126.949768,126.919556,126.886597,126.856384,126.826172,126.795959,126.765747,126.735535,126.702576,126.672363,126.642151,126.609192,126.578979,126.546021,126.513062,126.480103,126.44989,126.416931,126.386719,126.356506,126.323547,126.293335,126.263123,126.230164,126.197205,126.164246,126.131287,126.101074,126.068115,126.037903,126.004944,125.974731,125.941772,125.91156,125.878601,125.845642,125.812683,125.782471,125.752258,125.719299,125.689087,125.656128,125.623169,125.59021,125.559998,125.529785,125.496826,125.461121,125.428162,125.397949,125.367737,125.334778,125.299072,125.26886,125.238647,125.205688,125.175476,125.145264,125.115051,125.084839,125.054626,125.021667 },
        .output = {209.458466,210.572372,211.515701,212.979279,214.062119,215.198608,216.453629,217.730911,218.623856,219.980194,221.102036,222.191742,223.683655,224.93486,225.661118,227.057449,228.255478,229.394577,230.711685,231.808395,232.834503,233.927292,235.175964,236.302963,237.405533,238.494949,239.647354,240.858551,242.027344,243.139755,244.295547,245.372986,246.753662,247.974991,248.659653,250.114487,251.202698,252.335526,253.597412,254.733383,255.468735,256.948425,258.034271,259.194702,260.328644,261.428772,262.331848,263.796936,264.937012,265.929382,267.125366,268.311066,269.475281,270.619659,271.420532,272.893707,274.095703,275.235718,276.394165,277.616089,278.476379,280.074554,281.21991,282.307983,283.474304,284.628815,285.508148,287.094543,288.158783,289.267731,290.395386,291.78302,293.014526,294.131012,295.227997,296.36673,297.554871,298.672729,299.921082,301.046936,302.213501,303.395172,304.563965,305.501587,307.105682,308.385834,309.513092,310.514099,311.759491,313.106049,314.563721,315.465027,316.614685,317.535278,318.982971,320.210083,321.417084,322.327576,323.580414,325.082672,326.015564,327.329742,328.473267,329.849792,330.780182,332.156403,333.065186,334.308044,335.444916,336.800964,337.984436,339.123352,340.239929,341.44751,342.584656,343.914398,345.223846,346.224762,347.484558,348.693726,349.652985,350.967041,352.285095,353.478271,354.512329,355.902863,357.220459,358.324677,359.505188,0.591416359,1.99968338,2.88528442,4.29681301,5.32952785,6.65213585,7.62785912,8.55131149,10.0642061,11.311326,12.220788,13.4732294,14.77777,15.5408478,17.0873032,18.2391071,19.2428112,20.5153809,21.9309425,23.117939,24.1260185,25.3314247,26.2762928,27.6725006,28.8526306,30.2197418,31.2967873,32.5663948,33.5522881,34.7740898,36.1554489,37.3090973,38.511116,39.6057549,40.5813942,41.8440056,43.2163544,44.5526085,45.5772972,46.7126656,47.5453949,48.9793243,50.3305588,51.5598679,52.3841438,53.7003555,55.1805496,56.1045609,57.4116325,58.5725365,59.9536362,61.0034752,62.3683548,63.270565,64.6668167,65.704422,67.3246078,68.2944946,69.5541458,70.4898682,71.9554749,73.3274307,74.4003601,75.4482651,76.6742706,77.5857468,79.0431137,80.4284592,81.5773926,82.4738922,84.0211639,85.424324,86.356102,87.6712418,88.9251022,90.2377472,91.2483215,92.6145325,93.6427841,94.9945755,96.4135284,97.4526825,98.4701157,99.937088,100.748322,102.197998,103.603302,104.80648,105.575394,107.097046,108.344337,109.261734,110.634811,111.805588,113.132874,114.14241,115.552994,116.381004,117.90184,118.933395,120.360199,121.390343,122.835258,123.684471,125.081276,126.572845,127.694824,128.729218,130.044434,131.26001,132.184845,133.656799,134.919785,135.705307,137.055008,138.479828,139.479416,140.836823,142.011337,143.100266,144.226715,145.642059,146.554276,147.884995,148.90242,150.357178,151.433578,152.716873,153.963562,155.027039,156.368286,157.465973,158.484482,159.786316,160.555267,162.070145,163.427979,164.55687,165.534317,166.780533,167.599655,169.053757,170.402969,171.552505,172.431915,173.78894,175.191803,176.118393,177.401093,178.532074,179.768768,180.798187,182.094177,183.113129,184.480408,185.538651,186.895889,188.04306,189.472229,190.473145,191.715759,192.566986,194.177048,195.389435,196.794067,197.68425,198.989304,200.438904,201.592377,202.412628,203.845947,205.174911,206.120117,207.49028,208.570511,209.865479,210.854416,212.170975,213.236511,214.501663,215.469101,217.007706,218.144623,219.454865,220.463455,221.683838,223.125198,224.439438,225.515503,226.650223,227.530884,229.032288,230.486511,231.857483,233.017273,233.955353,235.443069,236.343262,237.567719,238.730972,240.109116,241.16153,242.405777,243.297424,244.586945,245.606064,247.181183,248.196594,249.373978,250.407822,251.638245,252.649933,254.12085,255.262527,256.382629,257.519928,258.753723,259.648895,261.03186,262.251556,263.510376,264.503693,265.833405,267.046783,268.086395,269.207947,270.509186,271.421173,272.913055,274.228149,275.257507,276.689301,277.657684,278.523712,279.964417,281.332428,282.234833,283.646179,284.830292,286.142181,287.111115,288.47644,289.385193,290.806549,292.042084,293.239502,294.266998,295.583862,296.482727,297.926331,298.993256,300.38504,301.396515,302.736115,303.625854,305.016479,306.454254,307.55603,308.646912,309.958252,311.308411,312.226349,313.712524,314.962708,315.726776,317.07251,318.500702,319.340118,320.733521,322.021179,323.200226,324.144501,325.560577,326.438263,327.808258,328.895874,330.403961,331.27359,332.757629,333.527313,334.955994,336.412018,337.533051,338.508301,339.831238,341.230286,342.25293,343.631317,344.799561,345.618988,347.070435,348.482849,349.334808,350.733063,352.045898,353.282928,354.330231,355.692108,356.522522,357.844269,359.005615,0.386838913,1.3452673,2.64766216,3.57326031,4.91483688,6.42258167,7.5039196,8.43132019,9.81049061,10.7155752,12.1283484,13.3630657,14.6445179,15.539217,16.9687271,18.2564449,19.1492558,20.5298004,21.6898441,22.9509964,23.9142323,25.351038,26.2899399,27.6827583,28.7691593,30.2417564,31.2094116,32.7055283,33.6148605,34.9008179,36.3177948,37.5458603,38.5387955,39.8420906,40.6127205,41.9850693,43.3832932,44.5880127,45.5957069,46.8360481,48.2422981,49.1160965,50.4659996,51.5907669,52.4698868,53.8272133,55.1854401,56.2251091,57.429184,58.4939575,59.7462273,60.8946838,62.3795547,63.2839127,64.6720505,65.6775131,67.3435745,68.3101959,69.5764999,70.5229568,71.9796753,73.3463593,74.4231033,75.4512253,76.8252487,78.23909,79.3044205,80.5817566,81.7781525,82.6030273,84.1434326,85.5696335,86.4584961,87.8308029,89.0071945,90.387825,91.2656174,92.7821579,93.6599045,95.1417694,96.5769882,97.6619339,98.5339279,100.09948,101.521523,102.400902,103.779861,105.000977,106.363968,107.336945,108.694611,109.523781,110.931488,112.241692,113.558807,114.501312,115.93396,116.64798,118.150063,119.409546,120.525345,121.565437,122.972374,124.237907,125.096085,126.609711,127.733101,128.663544,129.950287,131.275803,132.094543,133.524277,134.768478,135.671158,136.849655,138.261902,139.111938,140.440598,141.588715,142.446671,143.821381,145.18811,146.141037,147.42897,148.488251,149.849731,150.895508,152.14743,153.175247,154.543777,155.535812,157.155212,158.149689,159.335617,160.354218,161.697845,162.567749,164.054413,165.088287,165.672455,167.262421,168.673523,169.480804,170.94104,172.107391,173.38623,174.318222,175.722794,176.473083,177.861877,178.933807,180.402939,181.265961,182.680496,183.574341,184.953934,186.460556,187.40921,188.310852,189.633804,190.638763,191.963516,193.296295,194.39209,195.414505,196.812637,197.71138,199.126389,200.464569,201.632339,202.432831,203.868271,205.102432,206.14003,207.510925,208.50737,210.048203,211.030579,212.417435,213.367188,214.628525,215.51297,217.223907,218.323318,219.570007,220.566071,221.819504,223.144043,224.457428,225.421295,226.665588,227.532471,229.042847,230.378067,231.610931,232.385864,233.769058,235.033051,236.063568,237.366913,238.292252,239.535767,240.8134,241.968552,242.985306,244.240585,245.150726,246.665558,247.70668,248.593399,249.944504,251.380707,252.264069,253.644791,254.795517,255.536407,256.852356,258.276245,259.237946,260.615906,261.770203,263.046783,263.978943,265.489868,266.414856,267.72998,268.903595,270.399628,271.277924,272.680664,273.626892,275.055634,276.465057,277.537598,278.423096,279.864594,280.725861,282.152863,283.523499,284.699677,285.508392,286.885895,288.297485,289.213898,290.573608,291.84903,293.144409,294.074524,295.487213,296.417664,297.723572,298.782776,300.274841,301.212067,302.609497,303.510071,304.802124,306.305573,307.354156,308.42514,309.544037,310.506195,311.807922,313.150818,314.278778,315.42981,316.661285,317.458496,318.916229,320.260162,321.201752,322.33316,323.721802,324.496948,326.061401,327.270569,328.196503,329.445038,330.806488,331.560089,333.007202,334.364563,335.211853,336.877594,337.877686,338.618286,340.084015,341.496094,342.368927,343.97345,344.99884,345.639282,347.094849,348.621552,349.449524,350.754669,351.943298,353.30481,354.167755,355.601959,356.476959,357.870331,359.036713,0.403833389,1.23334408,2.67705917,3.51639748,4.92856979,6.20834827,7.3542738,8.26038837,9.70298767,10.6682825,12.0315742,13.3823776,14.4943571,15.5111074,16.9969654,18.2692757,19.1662502,20.5353355,21.6895866,22.6158295,23.9382648,25.2601433,26.2023067,27.5813065,28.5623932,29.9761105,30.9672832,32.3505745,33.3204613,34.6989021,35.5641174,37.2027969,38.1441879,38.8284721,40.3039894,41.6543617,42.414093,44.0483513,45.1320076,45.7757378,47.2625809,48.634201,49.4957275,51.0242844,52.2276726,53.5137596,54.3390656,55.7890015,56.5827637,57.9170914,59.0014725,60.3953629,61.3570099,62.7570381,63.530159,64.9397964,66.4122238,67.5402527,68.4431915,69.7028885,70.5357056,72.1210785,73.3640823,74.4464951,75.3831635,76.7301865,77.5328751,79.0947418,80.4798279,81.4903183,82.4684448,83.9468307,85.3569489,86.2858505,87.2719116,88.9212799,89.5741501,91.0053329,92.3987503,93.3395462,95.2423706,96.0366898,97.1997757,98.1366196,100.296852,100.862259,102.078484,103.398514,104.562805,105.519264,106.860664,108.163017,109.047462,110.594688,111.610794,112.475708,114.047012,115.436951,116.275475,117.663147,118.668526,120.230209,121.18203,122.705826,123.500275,124.771942,125.572144,127.329567,128.417984,129.710815,130.503113,131.973053,133.343719,134.356308,135.494003,136.730438,137.424423,138.862808,139.592163,141.129211,142.251923,143.586716,144.396439,145.892639,146.597534,148.015717,149.084854,150.633209,151.422592,152.838058,153.561707,155.028931,156.357758,157.450089,158.38324,159.672852,160.417175,161.955215,162.674606,164.388947,165.362427,166.553802,167.435593,168.916687,169.608521,171.073349,172.210602,173.567673,174.381866,175.873688,176.641785,178.161377,179.204391,180.684464,181.417664,182.992188,183.693985,185.189453,186.740585,187.881195,188.546936,190.130295,191.59285,192.445541,193.836975,195.006165,196.416443,197.280853,198.728821,199.468933,200.975388,202.14444,203.482544,204.276093,205.61467,206.486786,207.93515,208.963043,210.389771,211.21666,212.741882,213.55426,214.913483,216.322601,217.572342,218.545959,219.873032,221.125854,222.021027,223.409256,224.630417,225.515076,226.756012,227.471664,229.033615,230.353134,231.436096,232.323807,233.751175,234.460388,235.974915,237.298416,238.2099,239.298187,240.671051,241.49086,242.878662,244.119766,245.03949,246.493805,247.68956,248.52298,249.703278,251.017685,252.0186,253.367294,254.457428,255.361832,256.737274,257.528809,258.98877,260.252136,261.176636,262.260315,263.615753,264.328613,265.716064,266.601837,267.97818,269.015167,270.393402,271.258881,272.789703,273.615326,275.1492,276.571411,277.670074,278.476868,279.978973,281.341187,282.244507,283.653168,284.839752,285.530518,286.9953,288.270081,289.189514,290.420502,291.549133,292.460297,293.92392,294.620575,296.071167,297.469727,298.384003,299.85733,300.810333,301.612488,303.114502,304.37207,305.286957,306.799561,307.755341,308.64502,309.966553,311.309113,312.219818,313.714478,314.791931,315.63797,316.982697,318.171356,319.131256,320.478912,321.474152,322.463593,323.900177,325.201019,326.139221,327.347687,328.267487,329.549622,330.812805,331.546021,332.99707,334.246246,335.20224,336.689331,337.695251,338.505066,339.830994,341.229431,342.243988,343.631104,344.810211,345.552887,346.837036,348.252533,349.227692,350.483093,351.484344,352.398499,353.84198,354.528076,355.949524,357.25824,358.246918,359.234131,0.632400513,1.40170097,2.91296482,3.6557436,5.13048649,6.53841019,7.65369415,8.48633766,9.94820595,11.3180208,12.2352934,13.6487103,14.6503973,15.5327797,16.9795418,18.2623672,19.1609287,20.5334892,21.5498543,22.4545097,23.9186096,24.5956421,26.0813713,27.4580956,28.3649826,29.8392963,30.8177662,31.5974083,33.0988007,34.3566093,35.2130699,36.8091354,37.9381523,38.7096825,40.075119,41.3984604,42.1853981,43.6667061,44.9280319,45.7426071,47.1601868,48.6225281,49.4210968,50.860733,51.9967461,52.7545013,54.1616516,55.5488052,56.4153519,57.796627,58.7118835,60.1340942,61.1423492,62.510704,63.303524,64.6901627,65.5895386,67.3371353,68.1704254,69.4589996,70.3435287,71.8543625,72.5881729,74.0835571,75.1062317,75.6545181,77.2795029,78.6919785,79.6036682,80.9767914,82.0216522,83.4649353,84.2778397,85.6407013,86.4681549,87.8590393,88.8172531,90.4104004,91.2208099,92.7099304,93.629776,94.9893799,96.2746506,97.4275742,98.278801,99.7870178,100.714806,102.181351,103.408516,104.509338,105.389053,106.772217,107.577736,108.989822,110.208878,111.270004,112.293922,113.748489,114.444664,115.910225,117.288322,118.207916,119.416061,120.549889,121.415878,122.964432,123.681549,124.994286,126.43998,127.725464,128.556259,129.834152,130.594528,131.990692,133.372772,134.399704,135.411514,136.632538,137.441589,138.872803,139.587524,141.160248,142.168839,143.496246,144.33194,145.786728,146.564529,147.911987,148.930878,150.387939,151.263931,152.610397,153.433945,154.794052,155.598511,157.298218,158.128632,158.675873,160.151566,161.568939,162.417282,163.894989,164.935516,165.608475,167.044037,168.440582,169.298935,170.547516,171.567734,172.46312,173.900482,174.530869,175.998962,177.293152,178.276825,179.607498,180.744156,181.37822,183.049393,184.307114,185.216095,186.824692,187.687592,188.407166,189.884521,190.684799,192.070892,193.417831,194.544693,195.383392,196.789261,197.55954,198.876785,199.55159,201.150101,202.233063,203.619965,204.388184,205.766891,206.5746,207.955704,208.893143,210.318527,211.143372,212.536819,213.456848,214.742416,215.526779,217.224945,218.162216,218.783752,220.221893,221.573425,222.358093,223.898056,224.985275,225.678101,226.994659,228.3004,229.27449,230.618652,231.741318,232.473145,233.971024,235.345215,236.160355,237.586731,238.600906,239.892563,240.952835,242.199692,243.019379,244.371689,245.283676,246.840439,247.872849,248.570007,249.827682,251.227112,252.23407,253.619598,254.594543,255.475693,256.880005,258.144348,259.104614,260.353363,261.309296,262.340302,263.726074,264.431183,265.84317,266.62674,268.100342,269.087402,270.533386,271.277466,272.690826,273.574554,274.944061,275.713531,277.37381,278.254089,279.59729,280.487946,281.81134,282.540771,284.0,285.172302,286.502716,287.362518,288.740387,289.480957,290.83609,291.958252,293.355103,294.169464,295.478699,296.408356,297.834991,298.786896,300.274384,301.103333,302.503021,303.342163,304.726379,305.480896,307.201477,308.150665,308.771484,310.097351,311.443481,312.32251,313.737305,314.988495,315.684143,317.092712,318.404999,319.252563,320.622559,321.634491,322.47937,323.941467,324.549683,326.056152,327.362488,328.278595,329.620728,330.807037,331.524597,332.868347,334.128265,335.078705,336.561737,337.544891,338.417145,339.731903,340.540558,342.136536,343.505157,344.477234,345.49295,346.831909,348.152618,349.110718,350.368378,351.175476,352.260315,353.619141,354.333923,355.712402,356.477203,357.870331,358.814606,0.172176361,1.08335495,2.41699219,3.31375122,4.68287945,5.52341938,6.99099541,7.98375607,8.56822014,10.0955772,11.5525532,12.3437405,13.6749744,14.8551893,15.5875397,17.1255836,18.3862648,19.1913986,20.5542183,21.5770626,22.5234318,23.9260769,24.6128502,26.0862637,27.35849,28.1646957,29.5158005,30.6939545,31.4993477,32.8546562,33.6164474,34.919487,36.3365936,37.3692665,38.2789841,39.635067,40.3838539,41.7716522,42.4859314,44.2245178,45.2773628,46.5304031,47.2583351,48.7572823,49.5420761,51.0020981,52.1094856,53.32798,54.1825943,55.5629272,56.3441544,57.6874084,58.617939,60.0093842,61.0467758,62.393589,63.1029816,64.4512482,65.2737274,66.8503494,67.8750381,68.5260162,69.8170853,71.2010651,72.2274704,73.6241074,74.608284,75.5224686,76.9558792,78.3375397,79.2883301,80.5805511,81.6046829,82.5261612,84.0046844,85.4321747,86.1516953,87.568161,88.5550842,89.8986359,90.8676605,92.2631378,93.1647949,94.5361938,95.343132,96.7280502,97.6776428,98.4284439,99.8422089,100.689308,102.12204,103.355171,104.320122,105.304085,106.617638,107.449722,108.831467,109.533173,110.961311,111.970253,113.345131,114.158981,115.558189,116.262688,117.631905,118.492996,119.920151,120.919991,121.58445,123.055885,124.320816,125.142471,126.716354,127.87841,128.654114,129.954788,130.581314,132.01326,133.368011,134.376694,135.377136,136.609589,137.325836,138.712906,139.38295,140.811172,141.840408,142.609528,144.084625,145.492111,146.188538,147.477844,148.474304,149.851929,150.825684,151.486877,152.906815,153.520721,155.004044,156.481796,157.459915,158.248398,159.529984,160.213928,161.669876,162.52977,164.015274,164.884521,165.614517,167.024933,168.465088,169.311371,170.565491,171.435471,172.318069,173.91684,174.487823,176.022614,176.639343,178.185318,179.108139,180.595322,181.2966,182.757477,183.555664,184.983887,185.650925,187.268707,188.08078,188.578644,190.172348,191.623108,192.382187,193.721237,194.727051,195.486038,197.063446,197.67421,199.112564,200.464951,201.467072,202.398682,203.862259,204.515091,205.900146,206.601807,208.073196,209.293411,210.561096,211.348114,212.771057,213.560226,214.853699,216.219864,217.224899,218.161606,218.785049,220.227341,221.580078,222.341614,223.897202,224.972534,225.649521,226.985733,228.304733,229.168243,230.499512,231.459869,232.362473,233.761505,234.359192,235.833374,236.538864,238.05365,239.043365,240.537628,241.270279,242.543411,243.302795,244.616043,245.527695,247.033386,247.8974,248.584122,249.853302,251.141586,252.14975,253.517075,254.47876,255.366638,256.63501,257.408112,258.769531,259.579346,260.901733,261.935181,263.221741,264.159393,265.501862,266.216888,267.611725,268.57019,269.913177,270.778473,271.41806,272.95163,273.646912,275.043579,276.441498,277.521759,278.326904,279.714539,280.60965,281.925659,282.56369,283.98996,285.005951,286.398254,287.140656,288.510681,289.315674,290.706238,291.705505,292.958679,293.953857,294.578186,295.976715,297.265503,298.186768,299.419098,300.563721,301.32666,302.770325,303.585205,304.838806,306.087311,307.217682,308.163757,308.766968,310.210999,311.581177,312.3237,313.752655,314.834076,315.642883,316.88736,317.505554,318.919037,320.261414,321.207886,322.167603,323.415527,324.257172,325.592102,326.280731,327.728607,328.619476,330.016754,330.954651,331.54541,332.987823,334.367554,335.204529,336.710449,337.726166,338.432678,339.625885,340.441132,341.903503,342.634735,344.147369,345.006866,345.639587,347.096588,348.382996,349.246735,350.504547,351.349426,352.340393,353.750549,354.45636,355.852325,356.598694,358.008209,358.905579,0.316801071,1.09502792,2.42982388,3.33473682,4.70729828,5.37913799,6.87932968,7.8630352,8.49346161,9.83598232,10.6916714,12.1485186,13.3888578,14.3268585,15.269537,16.6242886,17.3614464,18.726368,19.4697037,20.8463001,21.8618927,23.1637287,24.061861,24.6010933,26.0964355,27.4804115,28.2794533,29.5162296,30.5680428,31.3434792,32.743679,33.4261627,34.710701,35.3867912,37.016758,37.9640274,38.7141037,39.9910049,40.6087303,42.0048103,43.3946648,44.4191818,45.4079094,46.644043,47.2699203,48.6419678,49.3502426,50.746109,51.7611847,52.5703087,53.9785347,54.5019722,55.934185,56.5378761,57.9423218,58.8670197,60.2870026,61.1747055,62.5266266,63.2191925,64.5822754,65.3722153,67.0217972,67.8847351,68.5303955,69.8251114,71.3331528,72.1186371,73.4923553,74.4477768,75.3789978,76.7367554,77.3931885,78.8356171,79.5432892,80.8357697,81.8617096,82.665596,84.0052872,85.3231277,86.0259552,87.3176651,88.0415573,89.1001968,90.4743423,91.1585388,92.5953064,93.3298874,94.8552704,95.5981369,97.132576,97.9585648,98.5619507,100.078712,100.726303,102.103111,103.486832,104.469635,105.441238,107.001129,107.600487,108.962105,109.580254,111.10907,112.169121,113.452766,114.233437,115.665565,116.348648,117.645203,118.420685,119.945465,120.937027,121.58548,123.068115,123.622711,124.981842,126.568634,127.695297,128.532394,129.852905,130.439423,131.784912,132.388306,134.063461,134.987213,135.763245,137.091858,137.56955,139.141724,140.46785,141.173157,142.265747,143.408875,144.337524,145.690475,146.267639,147.687531,148.408432,149.887207,150.802887,151.563049,152.982941,153.543457,155.049271,156.523804,157.506744,158.297073,159.569595,160.139511,161.564819,162.306564,163.878769,164.738739,165.519424,166.822205,167.435806,168.932266,169.543457,170.953491,171.843719,173.259109,174.231018,175.657318,176.229538,177.65271,178.274506,179.84079,180.687546,181.374969,182.88031,183.542496,184.968445,185.530457,187.250381,188.058472,188.537323,190.145752,191.609894,192.280228,193.708923,194.550873,195.456512,196.936417,197.485077,198.904724,199.480942,200.897675,201.768555,203.102188,204.121124,204.633713,206.155823,206.624985,208.098694,209.552704,210.483032,211.388931,212.798141,213.452515,214.754944,215.384308,217.032547,217.978241,218.719772,220.119843,221.477554,222.134369,223.566162,224.621277,225.527039,226.847458,227.324677,228.779297,229.327454,230.723755,231.938461,232.602325,234.1008,234.466141,236.050491,237.352631,238.152786,239.379211,240.663849,241.345078,242.653137,243.30043,244.626221,245.37355,247.047806,247.91658,248.591339,249.860641,250.505753,252.041092,253.399658,254.327194,255.143311,256.52356,257.128845,258.53186,259.255463,260.643005,261.523529,262.425873,263.85675,264.433624,265.892273,266.503571,267.882507,268.869385,270.194244,271.029205,272.472748,273.228912,274.611511,275.297028,276.770935,277.728668,278.423584,279.892517,280.581116,281.945862,282.53363,284.019684,284.885956,285.556976,286.810028 }
    };
    //        .input = {100.0, 125.0, 150.0, 175.0, 200.0},
    //        .output = {10.0, 20.0, 30.0, 40.0, 50.0}

    REAL linearInterpolate(REAL x, REAL x1, REAL x2, REAL y1, REAL y2) {
        return y1 + (x - x1) * (y2 - y1) / (x2 - x1);
    }

    REAL lookup(REAL x, DataTable* dataTable) { // ZJL_table
        int i;
        int low = LUT_LENGTH-1, high = 0, mid;
        if (x <= dataTable->input[low]) return dataTable->output[low];
        if (x >= dataTable->input[high]) return dataTable->output[high];
        while (low >= high) {
            mid = (low + high) / 2;
            if (dataTable->input[mid] > x) {
                high = mid;
            } else if (dataTable->input[mid] < x) {
                low = mid;
            } else {
                return dataTable->output[mid];
            }
            if (low - high == 1) {
                break;
            }
        }
        int index = high;
        return linearInterpolate(x, dataTable->input[index], dataTable->input[index + 1], dataTable->output[index], dataTable->output[index + 1]);
    }

#elif TRUE // CYM codes

    typedef struct
    {
        REAL x,y;
        /* data */
    }Point;

    Point A,B,C,D,O;
    REAL a_length, b_length, c_length, offset_length, lead;
    REAL joint_offset;

    Point get_intersections(Point p0, REAL r0, Point p1, REAL r1){
        REAL d, a, h, x2, y2, x3, y3, x4, y4;
        d = sqrt((p1.x-p0.x)*(p1.x-p0.x) + (p1.y-p0.y)*(p1.y-p0.y));

        a = (r0*r0-r1*r1+d*d)/(2*d);
        h = sqrt(r0*r0-a*a);
        x2 = p0.x+a*(p1.x-p0.x)/d;
        y2 = p0.y+a*(p1.y-p0.y)/d;
        x3 = x2+h*(p1.y-p0.y)/d;
        y3 = y2-h*(p1.x-p0.x)/d;

        x4 = x2-h*(p1.y-p0.y)/d;
        y4 = y2+h*(p1.x-p0.x)/d;
        Point ans;
        // printf("%lf,%lf\n", x4, y4);
        if(y4 >= 0.0){
            ans.x = x4;
            ans.y = y4;
        }
        else{
            ans.x = x3;
            ans.y = y3;
        }
        return ans;
    }

    REAL PositionCal(REAL joint_position){
        REAL distance, circles, motor_position;
        joint_position = (-1.0 *joint_position+joint_offset);
        B.x = a_length*cos(joint_position);
        B.y = a_length*sin(joint_position);


        C = get_intersections(B, b_length, D, c_length);

        distance = sqrt((C.x - O.x)*(C.x - O.x) + (C.y - O.y)*(C.y - O.y)) - offset_length;
        // printf("%lf, %lf\n",O.x, O.y);
        circles = distance/lead;
        motor_position = (circles - (int)circles ) * 2.0 * M_PI;
        return motor_position;
    }

    REAL get_motorpos(REAL angle){
        REAL deg_four_bar_map_motor_encoder_angle = PositionCal(angle / 180.0 * M_PI) / M_PI * 180.0 + 198.592172;
        while (deg_four_bar_map_motor_encoder_angle > 360.0){
            deg_four_bar_map_motor_encoder_angle -= 360.0;
        }
        return deg_four_bar_map_motor_encoder_angle;
    }
#endif


#ifdef _MMDv1 // mmlab drive version 1

// DC BUS
    #define OFFSET_VDC_BUS_IPM1 -1.01456189
    #define SCALE_VDC_BUS_IPM1 0.17604031

//Lem 1的三个蓝色块块分别是adc b7 b8 b9
    #define OFFSET_LEM_B7   2027 //2023.89473684 // ADCB7
    #define OFFSET_LEM_B8   2043 //2042.33333333 // ADCB8
    #define OFFSET_LEM_B9   2048 //2043.43859649 // ADCB9
    // 令逆变器输出端指向电机为正方向，若LEM上的箭头与正方向相同，则SCALE为正数，若LEM上的箭头与正方向相反，则SCALE为负数，
    #define SCALE_LEM_B7   0.03076297 // ADCB7
    #define SCALE_LEM_B8   0.03038256 // ADCB8
    #define SCALE_LEM_B9   0.03039058 // ADCB9

//Lem 2的三个蓝色块块分别是adc a1 a2 a3
    #define OFFSET_LEM_A1   2034 //2029.57894737 // ADCA1
    #define OFFSET_LEM_A2   2046 //2043.08771930 // ADCA2
    #define OFFSET_LEM_A3   2047 //2042.98245614 // ADCA3
    #define SCALE_LEM_A1   0.03080704 // ADCA1
    #define SCALE_LEM_A2   0.03060669 // ADCA2
    #define SCALE_LEM_A3   0.03045988 // ADCA3

#else
    scale and offset...
#endif

    // this offset is moved to ACMconfig.h
//#define OFFSET_COUNT_BETWEEN_ENCODER_INDEX_AND_U_PHASE_AXIS 2333 // cjh tuned with id_cmd = 3A 2024-01-19
#define ANGLE_SHIFT_FOR_FIRST_INVERTER  0.0 // Torque Inverter
#define ANGLE_SHIFT_FOR_SECOND_INVERTER 0.0 // Suspension Inverter
int USE_3_CURRENT_SENSORS = TRUE;


#define NO_POSITION_CONTROL 0
#define TWOMOTOR_POSITION_CONTROL 1
#define SINGLE_POSITION_CONTROL 2
#define SHANK_LOOP_RUN 3
#define HIP_LOOP_RUN 4
#define BOTH_LOOP_RUN 5
int positionLoopType = TWOMOTOR_POSITION_CONTROL; //BOTH_LOOP_RUN;
REAL legBouncingSpeed = 50;
REAL hipBouncingFreq = 10;
REAL legBouncingIq = 2;
REAL hipBouncingIq = 2;
int bool_use_SCI_encoder = TRUE;

REAL target_position_cnt;
REAL target_position_cnt_shank = 40000;
REAL target_position_cnt_hip = 40000;

void init_experiment_AD_gain_and_offset(){
    /* ADC OFFSET */
    //    // LEM1
    //    Axis->adc_offset[0] = OFFSET_VDC_BUS_IPM1;
    //    Axis->adc_offset[4] = OFFSET_LEM1_L; // b7
    //    Axis->adc_offset[5] = OFFSET_LEM1_R; // b8
    //    Axis->adc_offset[6] = OFFSET_LEM1_M; // b9
    //
    //    // LEM2
    //    Axis->adc_offset[1] = OFFSET_LEM2_L; // a1
    //    Axis->adc_offset[2] = OFFSET_LEM2_R; // a2
    //    Axis->adc_offset[3] = OFFSET_LEM2_M; // a3

    Axis->adc_scale[0] = SCALE_VDC_BUS_IPM1;
    Axis->adc_scale[1] = SCALE_LEM_A1;
    Axis->adc_scale[2] = SCALE_LEM_A2;
    Axis->adc_scale[3] = SCALE_LEM_A3;
    Axis->adc_scale[4] = SCALE_LEM_B7;
    Axis->adc_scale[5] = SCALE_LEM_B8;
    Axis->adc_scale[6] = SCALE_LEM_B9;

    Axis->adc_offset[0] = OFFSET_VDC_BUS_IPM1;
    Axis->adc_offset[1] = OFFSET_LEM_A1;
    Axis->adc_offset[2] = OFFSET_LEM_A2;
    Axis->adc_offset[3] = OFFSET_LEM_A3;
    Axis->adc_offset[4] = OFFSET_LEM_B7;
    Axis->adc_offset[5] = OFFSET_LEM_B8;
    Axis->adc_offset[6] = OFFSET_LEM_B9;


    /* two motor OFFSET */
    #if NUMBER_OF_AXES == 2
        Axis_1.pCTRL->enc->OffsetCountBetweenIndexAndUPhaseAxis = SHANK__OFFSET_COUNT_BETWEEN_ENCODER_INDEX_AND_U_PHASE_AXIS;
        Axis_2.pCTRL->enc->OffsetCountBetweenIndexAndUPhaseAxis = HIP__OFFSET_COUNT_BETWEEN_ENCODER_INDEX_AND_U_PHASE_AXIS;
    #else
        /* eQEP OFFSET */
        #if (ENCODER_TYPE == ABSOLUTE_ENCODER_SCI_SHANK)
            Axis->pCTRL->enc->OffsetCountBetweenIndexAndUPhaseAxis = SHANK__OFFSET_COUNT_BETWEEN_ENCODER_INDEX_AND_U_PHASE_AXIS;
        #elif (ENCODER_TYPE == ABSOLUTE_ENCODER_SCI_HIP)
            Axis->pCTRL->enc->OffsetCountBetweenIndexAndUPhaseAxis = HIP__OFFSET_COUNT_BETWEEN_ENCODER_INDEX_AND_U_PHASE_AXIS;
        #endif
    #endif  
}

#define SHANK_POS_CMD_FLAG 0
#define HIP_POS_CMD_FLAG 1

Uint64 mainWhileLoopCounter = 0;

int  use_first_set_three_phase=-1;
//int  FLAG_ENABLE_PWM_OUTPUT = FALSE;
void main(void){

    // CYM Codes
    //    A.x = 0.0;
    //    A.y = 0.0;
    //    D.x = 51.662e-3;
    //    D.y = 0.0;
    //    O.x = 110.76e-3;
    //    O.y = 192.03e-3;
    //    a_length = 80e-3;
    //    b_length = 139.98e-3;
    //    c_length = 153.069e-3;
    //    offset_length = 97.96e-3;
    //    lead = 16e-3;
    //    joint_offset =(147.6585661123+175.45166) / 180.0 *M_PI;

    InitSysCtrl();      // 1. Initialize System Control: PLL, WatchDog, enable Peripheral Clocks.
    Gpio_initialize();  // 2. Initialize GPIO and assign GPIO to peripherals.
    DINT;               // 3.1 Clear all interrupts and initialize PIE vector table.
    InitPieCtrl();      // 3.2 Initialize the PIE control registers to their default state. The default state is all PIE interrupts disabled and flags are cleared.
    IER = 0x0000;       // 3.3 Disable CPU __interrupts,
    IFR = 0x0000;       // 3.4 and clear all CPU __interrupt flags.
    InitPieVectTable(); // 3.5 Initialize the PIE vector table with pointers to the shell Interrupt Service Routines (ISR). At end, ENPIE = 1.

    // for Slessinv TIE.R1 for measuring the execution time
    InitCpuTimers();
    ConfigCpuTimer(&CpuTimer1, 200, 1000000); // 200MHz, INTERRUPT_period = 1e6 us

    // 4.1 IPC
    #if NUMBER_OF_DSP_CORES == 2
        IPCBootCPU2(C1C2_BROM_BOOTMODE_BOOT_FROM_FLASH);
    #endif
    #ifdef _STANDALONE
    #ifdef _FLASH
        // 当你需要离线断电再上电运行时用这个：
        //  Send boot command to allow the CPU02 application to begin execution
        IPCBootCPU2(C1C2_BROM_BOOTMODE_BOOT_FROM_FLASH);
    #else
        //  Send boot command to allow the CPU02 application to begin execution
        // 这句话我不知道什么意义，可能还是不要比较好。
        //IPCBootCPU2(C1C2_BROM_BOOTMODE_BOOT_FROM_RAM);
    #endif
    #endif

    // 4.2 Initialize peripherals
    ePWM_initialize();
    ADC_initialize();
    eQEP_initialize(0);
    InitECaptureContinuousMode();

    // 4.3 Assign peripherals to CPU02
    /* SPI and SCI */
    #if NUMBER_OF_DSP_CORES == 1
        // 同步！！！！！
        InitHighSpeedSpiGpio();
        //InitSpiaGpio();
        //InitSpicGpio();
        InitSpi();

        InitSciGpio();
        InitSci();
    #elif NUMBER_OF_DSP_CORES == 2
        /* 双核配置*/
        // 初始化SPI，用于与DAC芯片MAX5307通讯。
        EALLOW;
        DevCfgRegs.CPUSEL6.bit.SPI_A = 1; // assign spi-a to cpu2
        DevCfgRegs.CPUSEL6.bit.SPI_C = 1; // assign spi-c to cpu2

        DevCfgRegs.CPUSEL5.bit.SCI_A = 1; // assign sci-a to cpu2
        DevCfgRegs.CPUSEL5.bit.SCI_B = 1; // assign sci-b to cpu2

        DevCfgRegs.CPUSEL8.bit.CAN_A=1;// assign can-a to cpu2
        DevCfgRegs.CPUSEL8.bit.CAN_B=1;// assign can-b to cpu2

        //Allows CPU01 bootrom to take control of clock
        //configuration registers
        ClkCfgRegs.CLKSEM.all = 0xA5A50000;
        ClkCfgRegs.LOSPCP.all = 0x0001; //LSPCLK=100MHz
        EDIS;

        // 同步！！！！！
        InitHighSpeedSpiGpio();
        //InitSpicGpio();
        //InitSpiaGpio();
        //InitSpi(); // this is moved to CPU02

        // =========FOR EUREKA===========
        // https://www.ti.com/cn/lit/ds/symlink/tms320f28377d.pdf Chapter 7.2.1
        //GPIO62 - CANRXA
        GPIO_SetupPinMux(62, GPIO_MUX_CPU2, 6);
        GPIO_SetupPinOptions(62, GPIO_INPUT, GPIO_ASYNC);
        //GPIO19 - CANTXA
        GPIO_SetupPinMux(19, GPIO_MUX_CPU2, 3);
        GPIO_SetupPinOptions(19, GPIO_OUTPUT, GPIO_PUSHPULL);
        //GPIO21 - CANRXB
        GPIO_SetupPinMux(21, GPIO_MUX_CPU2, 3);
        GPIO_SetupPinOptions(21, GPIO_INPUT, GPIO_ASYNC);
        //GPIO20 - CANTXB
        GPIO_SetupPinMux(20, GPIO_MUX_CPU2, 3);
        GPIO_SetupPinOptions(20, GPIO_OUTPUT, GPIO_PUSHPULL);
        //GPIO136 - 485RX-SCIA
        GPIO_SetupPinMux(136, GPIO_MUX_CPU2, 6);
        GPIO_SetupPinOptions(136, GPIO_INPUT, GPIO_PUSHPULL);
        //GPIO135 - 485TX-SCIA
        GPIO_SetupPinMux(135, GPIO_MUX_CPU2, 6);
        GPIO_SetupPinOptions(135, GPIO_OUTPUT, GPIO_PUSHPULL);
        //GPIO138 - 485RX-SCIB
        GPIO_SetupPinMux(138, GPIO_MUX_CPU2, 6);
        GPIO_SetupPinOptions(138, GPIO_INPUT, GPIO_PUSHPULL);
        //GPIO137 - 485TX-SCIB
        GPIO_SetupPinMux(137, GPIO_MUX_CPU2, 6);
        GPIO_SetupPinOptions(137, GPIO_OUTPUT, GPIO_PUSHPULL);
        //GPIO140 - 485-SCIB-WE-(use SCICTX as GPIO, in UART3 pin7)
        GPIO_SetupPinMux(140, GPIO_MUX_CPU2, 0);
        GPIO_SetupPinOptions(140, GPIO_OUTPUT, GPIO_ASYNC);
        //GPIO139 - 485-SCIA-WE-(use SCICRX as GPIO, in UART3 pin8)
        GPIO_SetupPinMux(139, GPIO_MUX_CPU2, 0);
        GPIO_SetupPinOptions(139, GPIO_OUTPUT, GPIO_ASYNC);
        // =========FOR EUREKA===========


//        // =========TEST BOARD PIN============
//        // =========NOT FOR EUREKA===========
//        //GPIO30 - CANRXA
//        GPIO_SetupPinMux(30, GPIO_MUX_CPU2, 1);
//        GPIO_SetupPinOptions(30, GPIO_INPUT, GPIO_ASYNC);
//        //GPIO31 - CANTXA
//        GPIO_SetupPinMux(31, GPIO_MUX_CPU2, 1);
//        GPIO_SetupPinOptions(31, GPIO_OUTPUT, GPIO_PUSHPULL);
//        //GPIO28 - 485RX-SCIA
//        GPIO_SetupPinMux(28, GPIO_MUX_CPU2, 1);
//        GPIO_SetupPinOptions(28, GPIO_INPUT, GPIO_PUSHPULL);
//        //GPIO29 - 485TX-SCIA
//        GPIO_SetupPinMux(29, GPIO_MUX_CPU2, 1);
//        GPIO_SetupPinOptions(29, GPIO_OUTPUT, GPIO_PUSHPULL);
//        //GPIO8 - 485WE
//        GPIO_SetupPinMux(8,GPIO_MUX_CPU2,0);
//        GPIO_SetupPinOptions(8, GPIO_OUTPUT, GPIO_ASYNC);
//        InitScicGpio();
//        // =========TEST BOARD PIN============
//        // =========NOT FOR EUREKA===========

        // 异步！！！！！
        //InitSci(); // this is moved to CPU02

        // 在此之前，已经把GPIO和外设的权限转给CPU2了。
        // 这里再把部分共享内存权限给CPU2，同时告诉CPU2，你可以继续运行代码了。
        while( !(MemCfgRegs.GSxMSEL.bit.MSEL_GS0))
        {
            EALLOW;
            // Give Memory Access to GS0/ GS14 SARAM to CPU02
            MemCfgRegs.GSxMSEL.bit.MSEL_GS0 = 1;
            EDIS;
        }
    #endif

    // 4.4 Initialize algorithms
    for(axisCnt = 0; axisCnt < NUMBER_OF_AXES; axisCnt++){

        get_Axis_CTRL_pointers//(axisCnt, Axis, CTRL);
        Axis->ID = 100+axisCnt;
        Axis->pCTRL = CTRL;

        allocate_CTRL(CTRL);
        init_experiment();
        init_experiment_AD_gain_and_offset();

        //Axis->use_first_set_three_phase = 1; // -1;
        Axis->Set_current_loop = TRUE;
        Axis->Set_x_suspension_current_loop = FALSE;
        Axis->Set_y_suspension_current_loop = FALSE;
        Axis->Set_manual_rpm = 50.0;
        Axis->Set_manual_current_iq = 1.0;
        Axis->Set_manual_current_id = 0.0; // id = -1 A is the magic number to get more torque! cjh 2024-02-29
        Axis->Select_exp_operation = 0;    // 200; //202; //200; //101;
        //Axis->pFLAG_INVERTER_NONLINEARITY_COMPENSATION = &Axis->pCTRL->g->FLAG_INVERTER_NONLINEARITY_COMPENSATION;
        Axis->flag_overwrite_theta_d = FALSE;
        Axis->Overwrite_Current_Frequency = 0;
        Axis->Overwrite_Suspension_Current_Frequency = 0.5;
        Axis->used_theta_d_elec = 0.0;
        Axis->angle_shift_for_first_inverter = ANGLE_SHIFT_FOR_FIRST_INVERTER;
        Axis->angle_shift_for_second_inverter = ANGLE_SHIFT_FOR_SECOND_INVERTER;
        Axis->OverwriteSpeedOutLimitDuringInit = 6; // 10; // A

        Axis->FLAG_ENABLE_PWM_OUTPUT = FALSE;

        Axis->channels_preset = 2; // 9; // 101;    }

        Axis->pCTRL->enc->sum_qepPosCnt = 0;
        Axis->pCTRL->enc->cursor = 0;
        Axis->pCTRL->enc->flag_absolute_encoder_powered = FALSE;
    }axisCnt=1;

    // 5. Handle Interrupts
    /* Re-map PIE Vector Table to user defined ISR functions. */
        EALLOW; // This is needed to write to EALLOW protected registers
        PieVectTable.EPWM1_INT = &SYSTEM_PROGRAM;     //&MainISR;      // PWM主中断 10kKHz
        #if USE_ECAP_CEVT2_INTERRUPT == 1 && ENABLE_ECAP
        PieVectTable.ECAP1_INT = &ecap1_isr;
        PieVectTable.ECAP2_INT = &ecap2_isr;
        PieVectTable.ECAP3_INT = &ecap3_isr;
        #endif
        #if SYSTEM_PROGRAM_MODE != 223
        PieVectTable.EQEP1_INT = &EQEP_UTO_INT;      // eQEP
        #endif
        #if NUMBER_OF_DSP_CORES == 1
        //PieVectTable.SCIC_RX_INT = &scicRxFifoIsr;   // SCI Receive (Part 1/3)
        //PieVectTable.SCIC_TX_INT = &scicTxFifoIsr;   // SCI Transmit
        #endif
        EDIS; // This is needed to disable write to EALLOW protected registers
    /* PIE Control */
        /* ePWM */
        PieCtrlRegs.PIEIER3.bit.INTx1 = 1;      // PWM1 interrupt (Interrupt 3.1)
        /* SCI */
        #if NUMBER_OF_DSP_CORES == 1
            //PieCtrlRegs.PIEIER8.bit.INTx5 = 1;   // PIE Group 8, INT5, SCI-C Rx (Part 2/3)
            //PieCtrlRegs.PIEIER8.bit.INTx6 = 1;   // PIE Group 8, INT6, SCI-C Tx
        #endif
        /* eCAP */
        #if USE_ECAP_CEVT2_INTERRUPT == 1 && ENABLE_ECAP
            PieCtrlRegs.PIEIER4.bit.INTx1 = 1;      // Enable eCAP INTn in the PIE: Group 3 __interrupt 1--6 (Interrupt 4.1)
            PieCtrlRegs.PIEIER4.bit.INTx2 = 1;      // 1 Enable for Interrupt 4.2
            PieCtrlRegs.PIEIER4.bit.INTx3 = 1;      // 2 Enable for Interrupt 4.3
        #endif
        /* eQEP */
        #if SYSTEM_PROGRAM_MODE != 223
            PieCtrlRegs.PIEIER5.bit.INTx1 = 1;      // QEP interrupt
        #endif
    /* CPU Interrupt Enable Register (IER) */
        IER |= M_INT3;  // EPWM1_INT
        #if NUMBER_OF_DSP_CORES == 1
            //IER |= M_INT8; // SCI-C (Part 3/3)
        #endif
        #if USE_ECAP_CEVT2_INTERRUPT == 1 && ENABLE_ECAP
            IER |= M_INT4;  // ECAP1_INT // CPU INT4 which is connected to ECAP1-4 INT
        #endif
        #if SYSTEM_PROGRAM_MODE != 223 // used by yuanxin
        IER |= M_INT5;  // EQEP1_INT???
        #endif
    EINT;   // Enable Global __interrupt INTM
    ERTM;   // Enable Global realtime __interrupt DBGM

    // 6. Pre main loop
    DSP_STOP_LED1
    DSP_STOP_LED2
    DSP_PWM_DISABLE
    DSP_2PWM_DISABLE
    /* Test IPC to CPU02 */
    #if NUMBER_OF_DSP_CORES == 2
        Write.dac_buffer[0] = 0.5;
        Write.dac_buffer[1] = 0.5;
        Write.dac_buffer[2] = 0.5;
        Write.dac_buffer[3] = 0.5;
        Write.dac_buffer[4] = 0.5;
        Write.dac_buffer[5] = 0.5;
        Write.dac_buffer[6] = 0.5;
        Write.dac_buffer[7] = 0.5;
        Write.test = 200.0;
        IPCLtoRFlagSet(IPC_FLAG7);
    #endif

    if(FALSE){
        SendChar = 24;
        for(;;)
        {
            //SendChar = 0;
            ScicRegs.SCITXBUF.all = (SendChar);

            //
            // wait for RRDY/RXFFST =1 for 1 data available in FIFO
            //
            while(ScicRegs.SCIFFRX.bit.RXFFST == 0) {
            }
            (*CTRL).S->go_sensorless = 100;

            //
            // Check received character
            //
            ReceivedChar = ScicRegs.SCIRXBUF.all;
            if(ReceivedChar != SendChar)
            {
               //error();
            }

            //
            // Move to the next character and repeat the test
            //
            SendChar++;

            //
            // Limit the character to 8-bits
            //
            SendChar &= 0x00F;
            LoopCount++;
        }
    }

    // 7. Main loop
    while(1){
        mainWhileLoopCounter++;
        if (Motor_mode_START==1){
            Axis_1.FLAG_ENABLE_PWM_OUTPUT = 1;
            DSP_START_LED1
            DSP_START_LED2
        }else if (Motor_mode_START==0){
            Axis_1.FLAG_ENABLE_PWM_OUTPUT = 0;
            DSP_STOP_LED1
            DSP_STOP_LED2
        }

        #if NUMBER_OF_DSP_CORES == 1
            single_core_dac();
        #endif


    }
}

/* Below is moved from PanGuMainISR.c */
#if SYSTEM_PROGRAM_MODE==223
void DeadtimeCompensation(REAL Current_U, REAL Current_V, REAL Current_W, REAL CMPA[], REAL CMPA_DBC[]){

    // TODO: Add transitional linear range to dead time compensation

    int temp = 0;
    // ------------U--------------
    if (Current_U>=0){
        temp = (int)(CMPA[0] + SYSTEM_PWM_DEADTIME_COMPENSATION);
        if(temp>=SYSTEM_TBPRD)
            temp =  (int)((SYSTEM_PWM_UDC_UTILIZATION * 0.5 + 0.5) * SYSTEM_TBPRD);
    }else{
        temp = (int)(CMPA[0] - SYSTEM_PWM_DEADTIME_COMPENSATION);
        if (temp<=0)
            temp = (int)((-SYSTEM_PWM_UDC_UTILIZATION * 0.5 + 0.5) * SYSTEM_TBPRD);
    }
    CMPA_DBC[0] = (Uint16)temp;
    temp = 0;

    // --------------V--------------
    if (Current_V>=0)
    {
        temp = (int)(CMPA[1] + SYSTEM_PWM_DEADTIME_COMPENSATION);
        if(temp>=SYSTEM_TBPRD)
            temp =  (int)((SYSTEM_PWM_UDC_UTILIZATION * 0.5 + 0.5) * SYSTEM_TBPRD);
    }
    else
    {
        temp = (int)(CMPA[1] - SYSTEM_PWM_DEADTIME_COMPENSATION);
        if (temp<=0)
            temp = (int)((-SYSTEM_PWM_UDC_UTILIZATION * 0.5 + 0.5) * SYSTEM_TBPRD);
    }
    CMPA_DBC[1] = (Uint16)temp;
    temp = 0;

    // --------------W--------------
    if (Current_W>=0)
    {
        temp = (int)(CMPA[2] + SYSTEM_PWM_DEADTIME_COMPENSATION);
        if(temp>=SYSTEM_TBPRD)
            temp =  (int)((SYSTEM_PWM_UDC_UTILIZATION * 0.5 + 0.5) * SYSTEM_TBPRD);
    }
    else
    {
        temp = (int)(CMPA[2] - SYSTEM_PWM_DEADTIME_COMPENSATION);
        if (temp<=0)
            temp = (int)((-SYSTEM_PWM_UDC_UTILIZATION * 0.5 + 0.5) * SYSTEM_TBPRD);
    }
    CMPA_DBC[2] = (Uint16)temp;
}

REAL vvvf_voltage = 4;
REAL vvvf_frequency = 5;
REAL enable_vvvf = FALSE;


void voltage_commands_to_pwm(){
    if(axisCnt == 0){
        // SVPWM of the motor 3-phase
        (*CTRL).svgen1.Ualpha= (*CTRL).O->uab_cmd_to_inverter[0];
        (*CTRL).svgen1.Ubeta = (*CTRL).O->uab_cmd_to_inverter[1];

        if(enable_vvvf){
            (*CTRL).svgen1.Ualpha= vvvf_voltage * cos(vvvf_frequency*2*M_PI*(*CTRL).timebase);
            (*CTRL).svgen1.Ubeta = vvvf_voltage * sin(vvvf_frequency*2*M_PI*(*CTRL).timebase);
        }

        SVGEN_Drive(&(*CTRL).svgen1);
        (*CTRL).svgen1.CMPA[0] = (*CTRL).svgen1.Ta*SYSTEM_TBPRD;
        (*CTRL).svgen1.CMPA[1] = (*CTRL).svgen1.Tb*SYSTEM_TBPRD;
        (*CTRL).svgen1.CMPA[2] = (*CTRL).svgen1.Tc*SYSTEM_TBPRD;

        #if USE_DEATIME_PRECOMP
            DeadtimeCompensation(Axis->iuvw[0], Axis->iuvw[1], Axis->iuvw[2], (*CTRL).svgen1.CMPA, (*CTRL).svgen1.CMPA_DBC);
            EPwm1Regs.CMPA.bit.CMPA = (Uint16)(*CTRL).svgen1.CMPA_DBC[0];
            EPwm2Regs.CMPA.bit.CMPA = (Uint16)(*CTRL).svgen1.CMPA_DBC[1];
            EPwm3Regs.CMPA.bit.CMPA = (Uint16)(*CTRL).svgen1.CMPA_DBC[2];
        #else
            EPwm1Regs.CMPA.bit.CMPA = (Uint16)(*CTRL).svgen1.CMPA[0];
            EPwm2Regs.CMPA.bit.CMPA = (Uint16)(*CTRL).svgen1.CMPA[1];
            EPwm3Regs.CMPA.bit.CMPA = (Uint16)(*CTRL).svgen1.CMPA[2];
        #endif
    }
    if(axisCnt == 1){
        // SVPWM of the suspension 3-phase
        (*CTRL).svgen2.Ualpha = (*CTRL).O->uab_cmd_to_inverter[0];
        (*CTRL).svgen2.Ubeta  = (*CTRL).O->uab_cmd_to_inverter[1];

        if(enable_vvvf){
            (*CTRL).svgen2.Ualpha= vvvf_voltage * cos(vvvf_frequency*2*M_PI*(*CTRL).timebase);
            (*CTRL).svgen2.Ubeta = vvvf_voltage * sin(vvvf_frequency*2*M_PI*(*CTRL).timebase);
        }

        SVGEN_Drive(&(*CTRL).svgen2); //, -(*CTRL).UNot);
        (*CTRL).svgen2.CMPA[0] = (*CTRL).svgen2.Ta*SYSTEM_TBPRD;
        (*CTRL).svgen2.CMPA[1] = (*CTRL).svgen2.Tb*SYSTEM_TBPRD;
        (*CTRL).svgen2.CMPA[2] = (*CTRL).svgen2.Tc*SYSTEM_TBPRD;


        #if USE_DEATIME_PRECOMP
            DeadtimeCompensation(Axis->iuvw[3], Axis->iuvw[4], Axis->iuvw[5], (*CTRL).svgen2.CMPA, (*CTRL).svgen2.CMPA_DBC);
            EPwm4Regs.CMPA.bit.CMPA = (Uint16)(*CTRL).svgen2.CMPA_DBC[0];
            EPwm5Regs.CMPA.bit.CMPA = (Uint16)(*CTRL).svgen2.CMPA_DBC[1];
            EPwm6Regs.CMPA.bit.CMPA = (Uint16)(*CTRL).svgen2.CMPA_DBC[2];

        #else
            EPwm4Regs.CMPA.bit.CMPA = (Uint16)(*CTRL).svgen2.CMPA[0];
            EPwm5Regs.CMPA.bit.CMPA = (Uint16)(*CTRL).svgen2.CMPA[1];
            EPwm6Regs.CMPA.bit.CMPA = (Uint16)(*CTRL).svgen2.CMPA[2];
        #endif
    }

    //    svgen2.Ualpha = svgen1.Ualpha*0.5        + svgen1.Ubeta*0.8660254; // rotate 60 deg
    //    svgen2.Ubeta  = svgen1.Ualpha*-0.8660254 + svgen1.Ubeta*0.5;

}
void voltage_measurement_based_on_eCAP(){
    CAP.terminal_voltage[0] = (CAP.terminal_DutyOnRatio[0]) * Axis->vdc - Axis->vdc * 0.5; // -0.5 is due to duty ratio calculation; - vdc * 0.5 is referring to the center of dc bus capacitor.
    CAP.terminal_voltage[1] = (CAP.terminal_DutyOnRatio[1]) * Axis->vdc - Axis->vdc * 0.5;
    CAP.terminal_voltage[2] = (CAP.terminal_DutyOnRatio[2]) * Axis->vdc - Axis->vdc * 0.5;

    CAP.line_to_line_voltage[0] = CAP.terminal_voltage[0] - CAP.terminal_voltage[1];
    CAP.line_to_line_voltage[1] = CAP.terminal_voltage[1] - CAP.terminal_voltage[2];
    CAP.line_to_line_voltage[2] = CAP.terminal_voltage[2] - CAP.terminal_voltage[0];

    if(CAP.flag_bad_U_capture==FALSE && CAP.flag_bad_V_capture==FALSE && CAP.flag_bad_W_capture==FALSE){
        // Use ecap feedback
        CAP.uab0[0] = 0.33333 * (2*CAP.terminal_voltage[0] - CAP.terminal_voltage[1] - CAP.terminal_voltage[2]);
        CAP.uab0[1] = 0.57735 * (                            CAP.terminal_voltage[1] - CAP.terminal_voltage[2]);
        CAP.uab0[2] = 0.33333 * (  CAP.terminal_voltage[0] + CAP.terminal_voltage[1] + CAP.terminal_voltage[2]);
        CAP.dq[0] =  (*CTRL).S->cosT*CAP.uab0[0] + (*CTRL).S->sinT*CAP.uab0[1];
        CAP.dq[1] = -(*CTRL).S->sinT*CAP.uab0[0] + (*CTRL).S->cosT*CAP.uab0[1];

    }else{
        // Assume the voltage vector is rtoating at a constant speed when ecap measurement is disturbed.
        CAP.uab0[0] = (*CTRL).S->cosT*CAP.dq[0] - (*CTRL).S->sinT*CAP.dq[1];
        CAP.uab0[1] = (*CTRL).S->sinT*CAP.dq[0] + (*CTRL).S->cosT*CAP.dq[1];
    }

    // 电压测量
    if(G.flag_use_ecap_voltage==2 || G.flag_use_ecap_voltage==1){
        /*Use original ecap measured voltage*/
        US_P(0) = US_C(0);
        US_P(1) = US_C(1);
        US_C(0) = CAP.uab0[0];
        US_C(1) = CAP.uab0[1];
    }
    //    else if(G.flag_use_ecap_voltage==3){
    //        ecap_moving_average();
    //    }
    if(G.flag_use_ecap_voltage==10){
        /*Use lpf ecap measured voltage*/
        CAP.dq_lpf[0] = _lpf(CAP.dq[0], CAP.dq_lpf[0], 800);
        CAP.dq_lpf[1] = _lpf(CAP.dq[1], CAP.dq_lpf[1], 800);
        CAP.uab0[0] = (*CTRL).S->cosT*CAP.dq_lpf[0] - (*CTRL).S->sinT*CAP.dq_lpf[1];
        CAP.uab0[1] = (*CTRL).S->sinT*CAP.dq_lpf[0] + (*CTRL).S->cosT*CAP.dq_lpf[1];
        US_P(0) = US_C(0);
        US_P(1) = US_C(1);
        US_C(0) = CAP.uab0[0];
        US_C(1) = CAP.uab0[1];

    }else if(G.flag_use_ecap_voltage==0){
        /*Use command voltage for feedback*/
        US_P(0) = (*CTRL).O->uab_cmd[0]; // 后缀_P表示上一步的电压，P = Previous
        US_P(1) = (*CTRL).O->uab_cmd[1]; // 后缀_C表示当前步的电压，C = Current
        US_C(0) = (*CTRL).O->uab_cmd[0]; // 后缀_P表示上一步的电压，P = Previous
        US_C(1) = (*CTRL).O->uab_cmd[1]; // 后缀_C表示当前步的电压，C = Current
    }

    // (for watch only) Mismatch between ecap measurement and command to inverter
    (*CTRL).O->udq_cmd_to_inverter[0] = (*CTRL).S->cosT*(*CTRL).O->uab_cmd_to_inverter[0] + (*CTRL).S->sinT*(*CTRL).O->uab_cmd_to_inverter[1];
    (*CTRL).O->udq_cmd_to_inverter[1] =-(*CTRL).S->sinT*(*CTRL).O->uab_cmd_to_inverter[0] + (*CTRL).S->cosT*(*CTRL).O->uab_cmd_to_inverter[1];
    CAP.dq_mismatch[0] = (*CTRL).O->udq_cmd_to_inverter[0] - CAP.dq[0];
    CAP.dq_mismatch[1] = (*CTRL).O->udq_cmd_to_inverter[1] - CAP.dq[1];
}

//extern long long sci_pos;

//声明全局变量
#if PC_SIMULATION==FALSE
REAL CpuTimer_Delta = 0;
Uint32 CpuTimer_Before = 0;
Uint32 CpuTimer_After = 0;
#endif

int counter_missing_position_measurement = 0;
int max_counter_missing_position_measurement = 0;

void measurement(){

    CTRL->enc->encoder_abs_cnt_previous = CTRL->enc->encoder_abs_cnt;

    if(axisCnt == 0)
    {
        #if (ENCODER_TYPE == ABSOLUTE_ENCODER_SCI_SHANK)
            position_count_SCI_fromCPU2 = position_count_SCI_shank_fromCPU2;
        #elif (ENCODER_TYPE == ABSOLUTE_ENCODER_SCI_HIP)
            position_count_SCI_fromCPU2 = position_count_SCI_hip_fromCPU2;
        #endif

        #if NUMBER_OF_AXES == 2
            position_count_SCI_fromCPU2 = position_count_SCI_shank_fromCPU2;
        #endif

        // 編碼器讀數是反的，所以這邊偏置也要反一下，改成負值！
        // 編碼器讀數是反的，所以這邊偏置也要反一下，改成負值！
        // 編碼器讀數是反的，所以這邊偏置也要反一下，改成負值！
        // MD1 is 17bit, use SCI485hip port
        // 膝盖电机，正转电流导致编码器读数减小：
        CTRL->enc->encoder_abs_cnt = - ( (int32)position_count_SCI_fromCPU2 - CTRL->enc->OffsetCountBetweenIndexAndUPhaseAxis );
    }
    if(axisCnt == 1)
    {
        #if NUMBER_OF_AXES == 2
            position_count_SCI_fromCPU2 = position_count_SCI_hip_fromCPU2;
        #endif

        // 大腿电机，正转电流导致编码器读数增大
        CTRL->enc->encoder_abs_cnt = (int32)position_count_SCI_fromCPU2 - CTRL->enc->OffsetCountBetweenIndexAndUPhaseAxis;
    }

    if(! bool_use_SCI_encoder){
            // 正转电流导致编码器读数减小：
            CTRL->enc->encoder_abs_cnt = - ( (int32)cnt_four_bar_map_motor_encoder_angle + CTRL->enc->OffsetCountBetweenIndexAndUPhaseAxis );
            // 正转电流导致编码器读数增大：
            //CTRL->enc->encoder_abs_cnt = (int32)cnt_four_bar_map_motor_encoder_angle - CTRL->enc->OffsetCountBetweenIndexAndUPhaseAxis;
    }

    // ignore this please
        if (CTRL->enc->flag_absolute_encoder_powered == FALSE){
            CTRL->enc->flag_absolute_encoder_powered = TRUE;
            // assume there motor is at still when it is powered on
            CTRL->enc->encoder_abs_cnt_previous = CTRL->enc->encoder_abs_cnt;
        }

    while(CTRL->enc->encoder_abs_cnt > SYSTEM_QEP_QPOSMAX_PLUS_1) {CTRL->enc->encoder_abs_cnt -= SYSTEM_QEP_QPOSMAX_PLUS_1;}
    while(CTRL->enc->encoder_abs_cnt < 0)                         {CTRL->enc->encoder_abs_cnt += SYSTEM_QEP_QPOSMAX_PLUS_1;}

    CTRL->enc->theta_d__state = CTRL->enc->encoder_abs_cnt * CNT_2_ELEC_RAD;
    while(CTRL->enc->theta_d__state> M_PI) CTRL->enc->theta_d__state -= 2*M_PI;
    while(CTRL->enc->theta_d__state<-M_PI) CTRL->enc->theta_d__state += 2*M_PI;
    CTRL->enc->theta_d_elec = CTRL->enc->theta_d__state;

    CTRL->enc->encoder_incremental_cnt = CTRL->enc->encoder_abs_cnt - CTRL->enc->encoder_abs_cnt_previous;
    if(        CTRL->enc->encoder_incremental_cnt < -0.5*    SYSTEM_QEP_QPOSMAX_PLUS_1)
                CTRL->enc->encoder_incremental_cnt += (int32) SYSTEM_QEP_QPOSMAX_PLUS_1;
    else if (  CTRL->enc->encoder_incremental_cnt >  0.5*    SYSTEM_QEP_QPOSMAX_PLUS_1)
                CTRL->enc->encoder_incremental_cnt -= (int32) SYSTEM_QEP_QPOSMAX_PLUS_1;

    CTRL->enc->rpm_raw =  CTRL->enc->encoder_incremental_cnt  * SYSTEM_QEP_REV_PER_PULSE * 1e4 * 60; // 1e4指的是EPWM1_ISR中断的频率：10kHz

//                #define ENC(X) (*Axis[X].pCTRL->enc)
//                ENC(0)
//                ENC(1)

    CTRL->enc->sum_qepPosCnt            -= CTRL->enc->MA_qepPosCnt[CTRL->enc->cursor];
    CTRL->enc->sum_qepPosCnt            += CTRL->enc->rpm_raw;//CTRL->enc->encoder_incremental_cnt;
    CTRL->enc->MA_qepPosCnt[CTRL->enc->cursor]  = CTRL->enc->rpm_raw;//CTRL->enc->encoder_incremental_cnt;

    CTRL->enc->cursor+=1;
    if(CTRL->enc->cursor>=MA_SEQUENCE_LENGTH){
        CTRL->enc->cursor=0; // Reset CTRL->enc->cursor
    }

    CTRL->enc->rpm = CTRL->enc->sum_qepPosCnt * MA_SEQUENCE_LENGTH_INVERSE; // CL_TS_INVERSE;
    //CTRL->enc->rpm = CTRL->enc->rpm_raw;

    CTRL->enc->omg_elec = CTRL->enc->rpm * RPM_2_ELEC_RAD_PER_SEC;

    // end of axiscnt


    // 转子位置和转速接口 以及 转子位置和转速测量
    //    int32 QPOSCNT;
    //    if(ENCODER_TYPE == INCREMENTAL_ENCODER_QEP){
    //        QPOSCNT = EQep1Regs.QPOSCNT;
    //    }
    //    // 20240123 腿部电机测试
    //    if(ENCODER_TYPE == ABSOLUTE_ENCODER_SCI){
    //        QPOSCNT =  - position_count_SCI_fromCPU2; // TODO: 开环电流矢量正转的时候，电机的编码器读数在减小，所以取个负号。
    //        //QPOSCNT = position_count_SCI_fromCPU2;
    //    }
    //    // 使用can_ID0x01编码器
    //    if(ENCODER_TYPE == ABSOLUTE_ENCODER_CAN_ID0x01){
    //        QPOSCNT = position_count_CAN_ID0x01_fromCPU2;
    //    }
    //    // 使用can_ID0x03编码器
    //    if(ENCODER_TYPE == ABSOLUTE_ENCODER_CAN_ID0x03){
    //        QPOSCNT = position_count_CAN_ID0x03_fromCPU2;
    //    }

    // CTRL->enc->rpm = PostionSpeedMeasurement_MovingAvergage(QPOSCNT, CTRL->enc);


    if((*CTRL).S->go_sensorless == FALSE){
        CTRL->I->omg_elec     = CTRL->enc->omg_elec;
        CTRL->I->theta_d_elec = CTRL->enc->theta_d_elec;
    }

    // Convert adc results
    //Axis->vdc    =((REAL)(AdcaResultRegs.ADCRESULT0 ) - Axis->adc_offset[0]) * Axis->adc_scale[0];
    Axis->vdc    =((REAL)(AdcbResultRegs.ADCRESULT6 ) - Axis->adc_offset[0]) * Axis->adc_scale[0];
    if(G.flag_overwite_vdc) Axis->vdc = G.overwrite_vdc;


    if(axisCnt == 0){
        // LEM1
        Axis->iuvw[0]=((REAL)(AdcaResultRegs.ADCRESULT1 ) - Axis->adc_offset[1]) * Axis->adc_scale[1]; //
        Axis->iuvw[1]=((REAL)(AdcaResultRegs.ADCRESULT2 ) - Axis->adc_offset[2]) * Axis->adc_scale[2]; //
        Axis->iuvw[2]=((REAL)(AdcaResultRegs.ADCRESULT3 ) - Axis->adc_offset[3]) * Axis->adc_scale[3]; //

        // 电流接口
        if(USE_3_CURRENT_SENSORS){
            Axis->iabg[0] = UVW2A_AI(Axis->iuvw[0], Axis->iuvw[1], Axis->iuvw[2]);
            Axis->iabg[1] = UVW2B_AI(Axis->iuvw[0], Axis->iuvw[1], Axis->iuvw[2]);
            Axis->iabg[2] = UVW2G_AI(Axis->iuvw[0], Axis->iuvw[1], Axis->iuvw[2]);
        }else{
            REAL phase_V_current = -Axis->iuvw[0] - Axis->iuvw[2];
            Axis->iabg[0] = UV2A_AI(Axis->iuvw[0], phase_V_current);
            Axis->iabg[1] = UV2B_AI(Axis->iuvw[0], phase_V_current);
        }
    }
    if(axisCnt == 1){
        // LEM2
        Axis->iuvw[3]=((REAL)(AdcbResultRegs.ADCRESULT7 ) - Axis->adc_offset[4]) * Axis->adc_scale[4]; //
        Axis->iuvw[4]=((REAL)(AdcbResultRegs.ADCRESULT8 ) - Axis->adc_offset[5]) * Axis->adc_scale[5]; //
        Axis->iuvw[5]=((REAL)(AdcbResultRegs.ADCRESULT9 ) - Axis->adc_offset[6]) * Axis->adc_scale[6]; //

        // 电流接口
        if(USE_3_CURRENT_SENSORS){
            Axis->iabg[0] = UVW2A_AI(Axis->iuvw[3], Axis->iuvw[4], Axis->iuvw[5]);
            Axis->iabg[1] = UVW2B_AI(Axis->iuvw[3], Axis->iuvw[4], Axis->iuvw[5]);
            Axis->iabg[2] = UVW2G_AI(Axis->iuvw[3], Axis->iuvw[4], Axis->iuvw[5]);
        }else{
            REAL phase_V_current = -Axis->iuvw[3] - Axis->iuvw[5];
            Axis->iabg[0] = UV2A_AI(Axis->iuvw[3], phase_V_current);
            Axis->iabg[1] = UV2B_AI(Axis->iuvw[3], phase_V_current);
        }
    }

    // 只用第一套三相
    IS_C(0)        = Axis->iabg[0];
    IS_C(1)        = Axis->iabg[1];
    (*CTRL).I->iab[0] = Axis->iabg[0];
    (*CTRL).I->iab[1] = Axis->iabg[1];

    US_C(0) = (*CTRL).O->uab_cmd[0]; // 后缀_P表示上一步的电压，P = Previous
    US_C(1) = (*CTRL).O->uab_cmd[1]; // 后缀_C表示当前步的电压，C = Current

    US_P(0) = US_C(0);
    US_P(1) = US_C(1);

    // 线电压测量（基于占空比和母线电压）
    //voltage_measurement_based_on_eCAP();
    // int axisCnt = 0;

    {
        //pAxis = list_pointer_to_Axes[axisCnt];

        // Vdc用于实时更新电流环限幅
        PID_iD->OutLimit = Axis->vdc * 0.5773672;
        PID_iQ->OutLimit = Axis->vdc * 0.5773672;

        PID_iX->outLimit = Axis->vdc * 0.5773672;
        PID_iY->outLimit = Axis->vdc * 0.5773672;
    }

    //    这样不能形成保护，必须设置故障状态才行。
    //    if(fabs(G.Current_W)>8 || fabs(G.Current_V)>8){
    //        DSP_PWM_DISABLE
    //        DSP_2PWM_DISABLE
    //    }

    // 电流采样ADC温飘校准 // TODO 改成用ADC Raw Results校准。
    //    if(Axis->AD_offset_flag2==FALSE)
    //    {
    //        Axis->offset_counter += 1;
    //        Axis->iuvw_offset_online[0] += (REAL)(AdcaResultRegs.ADCRESULT1 ) ;
    //        Axis->iuvw_offset_online[1] += (REAL)(AdcaResultRegs.ADCRESULT2 ) ;
    //        Axis->iuvw_offset_online[2] += (REAL)(AdcaResultRegs.ADCRESULT3 ) ;
    //        Axis->iuvw_offset_online[3] += (REAL)(AdcaResultRegs.ADCRESULT11 ) ;
    //        Axis->iuvw_offset_online[4] += (REAL)(AdcaResultRegs.ADCRESULT9 ) ;
    //        Axis->iuvw_offset_online[5] += (REAL)(AdcaResultRegs.ADCRESULT8 ) ;
    //        if(Axis->offset_counter>=5000){
    //            Axis->iuvw_offset_online[0] = Axis->iuvw_offset_online[0] / 5000;
    //            Axis->iuvw_offset_online[1] = Axis->iuvw_offset_online[1] / 5000;
    //            Axis->iuvw_offset_online[2] = Axis->iuvw_offset_online[2] / 5000;
    //            Axis->iuvw_offset_online[3] = Axis->iuvw_offset_online[3] / 5000;
    //            Axis->iuvw_offset_online[4] = Axis->iuvw_offset_online[4] / 5000;
    //            Axis->iuvw_offset_online[5] = Axis->iuvw_offset_online[5] / 5000;
    //            Axis->AD_offset_flag2 = TRUE;
    //            Axis->offset_counter = 0;
    //        }
    //
    //        // 来不及完成偏置检测（比如刚上电数字开关就是开的），采用默认值
    //        /* 427-1401：添加开关信号滤波。今天发现在刚上电的时候，XCUBE-II的前两个中断里，数字开关是打开的，然后才变成关闭。*/
    //        if(Axis->FLAG_ENABLE_PWM_OUTPUT && Axis->offset_counter>100){
    //            Axis->iuvw_offset_online[0] = 0.0;
    //            Axis->iuvw_offset_online[1] = 0.0;
    //            Axis->iuvw_offset_online[2] = 0.0;
    //            Axis->iuvw_offset_online[3] = 0.0;
    //            Axis->iuvw_offset_online[4] = 0.0;
    //            Axis->iuvw_offset_online[5] = 0.0;
    //            Axis->AD_offset_flag2 = TRUE;
    //        }
    //
    //        // 上电的时候，电机可能在转，此时根据电流判断是否还要额外进行偏置补偿。
    //        if( fabs(Axis->iuvw[0])>0.05 || fabs(Axis->iuvw[1])>0.05 || fabs(Axis->iuvw[2])>0.05 || \
    //            fabs(Axis->iuvw[3])>0.05 || fabs(Axis->iuvw[4])>0.05 || fabs(Axis->iuvw[5])>0.05){
    //            Axis->iuvw_offset_online[0] = 0.0;
    //            Axis->iuvw_offset_online[1] = 0.0;
    //            Axis->iuvw_offset_online[2] = 0.0;
    //            Axis->iuvw_offset_online[3] = 0.0;
    //            Axis->iuvw_offset_online[4] = 0.0;
    //            Axis->iuvw_offset_online[5] = 0.0;
    //            Axis->AD_offset_flag2 = TRUE;
    //        }
    //    }
}

REAL call_position_loop_controller(int positionLoopType){
    if (positionLoopType == TWOMOTOR_POSITION_CONTROL)
    {
        Axis->flag_overwrite_theta_d = FALSE;
        Axis->Set_current_loop = FALSE;
        if (axisCnt == 0)
        {
        #if NUMBER_OF_AXES == 2
                    PID_pos->Fbk = position_count_CAN_ID0x03_fromCPU2;
                    PID_pos->Ref = hip_shank_angle_to_can(
                        look_up_hip_shank_angle(
                            // 11,
                            // 0.0001怎么慢不下来 0.01会不动？
                            // 明哥 ：0.1
                            target_tick, // 0.1* (double)((*CTRL).timebase_counter),
                            SHANK_TYPE),
                        SHANK_TYPE);
        #endif
        }
        if (axisCnt == 1)
        {
        #if NUMBER_OF_AXES == 2
                    PID_pos->Fbk = position_count_CAN_ID0x01_fromCPU2;
                    PID_pos->Ref = hip_shank_angle_to_can(
                        look_up_hip_shank_angle(
                            // 24,
                            // 明哥 ：0.1
                            // 0.0001怎么慢不下来 0.01会不动？
                            target_tick, // 0.1* (double)((*CTRL).timebase_counter),
                            HIP_TYPE),
                        HIP_TYPE);
        #endif
        }
        // 位置环
        // 长弧和短弧，要选短的。
        PID_pos->Err = PID_pos->Ref - PID_pos->Fbk;
        if (PID_pos->Err > (CAN_QMAX * 0.5))
        {
            PID_pos->Err -= CAN_QMAX;
        }
        if (PID_pos->Err < -(CAN_QMAX * 0.5))
        {
            PID_pos->Err += CAN_QMAX;
        }
        PID_pos->Out = PID_pos->Err * PID_pos->Kp;
        if (PID_pos->Out > PID_pos->OutLimit)
        {
            PID_pos->Out = PID_pos->OutLimit;
        }
        if (PID_pos->Out < -PID_pos->OutLimit)
        {
            PID_pos->Out = -PID_pos->OutLimit;
        }
        Axis->Set_manual_rpm = PID_pos->Out;
    }
    else if (positionLoopType == SINGLE_POSITION_CONTROL)
    {
        Axis->flag_overwrite_theta_d = FALSE;
        Axis->Set_current_loop = FALSE;
        // 位置环
        // 长弧和短弧，要选短的。
        if (axisCnt == 0)
        {
        #if NUMBER_OF_AXES == 2
                    PID_pos->Fbk = position_count_CAN_ID0x03_fromCPU2;
                    PID_pos->Ref = target_position_cnt_hip;
        #endif
        }
        if (axisCnt == 1)
        {
        #if NUMBER_OF_AXES == 2
                    PID_pos->Fbk = position_count_CAN_ID0x01_fromCPU2;
                    PID_pos->Ref = target_position_cnt_shank;
        #endif
        }
        PID_pos->Err = PID_pos->Ref - PID_pos->Fbk;
        if (PID_pos->Err > (CAN_QMAX * 0.5))
        {
            PID_pos->Err -= CAN_QMAX;
        }
        if (PID_pos->Err < -(CAN_QMAX * 0.5))
        {
            PID_pos->Err += CAN_QMAX;
        }
        PID_pos->Out = PID_pos->Err * PID_pos->Kp;
        if (PID_pos->Out > PID_pos->OutLimit)
        {
            PID_pos->Out = PID_pos->OutLimit;
        }
        if (PID_pos->Out < -PID_pos->OutLimit)
        {
            PID_pos->Out = -PID_pos->OutLimit;
        }
        Axis->Set_manual_rpm = PID_pos->Out;
    }
    else if (positionLoopType == SHANK_LOOP_RUN)
    { // shank motor only
        if (axisCnt == 0)
        {
            Axis->flag_overwrite_theta_d = FALSE;
            Axis->Set_current_loop = FALSE;
            if (position_count_CAN_ID0x03_fromCPU2 > 62000)
            {
                Axis->Set_manual_rpm = -legBouncingSpeed;
            }
            else if (position_count_CAN_ID0x03_fromCPU2 < 33000)
            {
                Axis->Set_manual_rpm = legBouncingSpeed;
            }
        }
    }
    else if (positionLoopType == HIP_LOOP_RUN)
    { // hip motor only
    #if NUMBER_OF_AXES == 2
            if (axisCnt == 1)
            {
                Axis_2.flag_overwrite_theta_d = TRUE;
                Axis_2.Set_current_loop = TRUE;
                Axis_2.Set_manual_current_iq = 5;
                if (position_count_CAN_ID0x01_fromCPU2 > 58000)
                {
                    Axis_2.Overwrite_Current_Frequency = 10;
                }
                else if (position_count_CAN_ID0x01_fromCPU2 < 48000)
                {
                    Axis_2.Overwrite_Current_Frequency = -10;
                }
            }
    #else
            Axis->flag_overwrite_theta_d = TRUE;
            Axis->Set_current_loop = TRUE;
            Axis->Set_manual_current_iq = 5;
            if (position_count_CAN_ID0x01_fromCPU2 > 58000)
            {
                Axis->Overwrite_Current_Frequency = hipBouncingFreq;
            }
            else if (position_count_CAN_ID0x01_fromCPU2 < 48000)
            {
                Axis->Overwrite_Current_Frequency = -hipBouncingFreq;
            }
    #endif
    }
    else if (positionLoopType == BOTH_LOOP_RUN)
    {
    #if NUMBER_OF_AXES == 2
        if (axisCnt == 0)
        {
            // CAN03越大，小腿越伸出，legBouncingIq, rpm为正数，小腿伸出
            // CAN03越小，小腿越收起，legBouncingIq, rpm为负数，小腿收起
            Axis_1.flag_overwrite_theta_d = FALSE;
            Axis_1.Set_current_loop = TRUE;
            if (position_count_CAN_ID0x03_fromCPU2 > 56000)
            {
                Axis_1.Set_manual_current_iq = -legBouncingIq; // CAN03太大，小腿伸出过头，需要iq为负数，收起小腿
            }
            else if (position_count_CAN_ID0x03_fromCPU2 < 35000)
            {
                Axis_1.Set_manual_current_iq = legBouncingIq;
            }
        }
        // 大腿电机
        if (axisCnt == 1)
        {
            // CAN01越小,大腿越抬起,hipBouncingIq为正数，大腿抬起
            // CAN01越大,大腿越放下,hipBouncingIq为负数，大腿放下
            Axis_2.flag_overwrite_theta_d = FALSE;
            Axis_2.Set_current_loop = TRUE;
            if (position_count_CAN_ID0x01_fromCPU2 > 58000)
            {
                Axis_2.Set_manual_current_iq = hipBouncingIq; // CAN01太大,大腿放下过多,需要iq为正数,抬起大腿
            }
            else if (position_count_CAN_ID0x01_fromCPU2 < 51000)
            {
                Axis_2.Set_manual_current_iq = -hipBouncingIq;
            }
        }
    #endif
    }

    return Axis->Set_manual_rpm;
}

// int down_freq_ecap_counter = 1;
// Uint64 timebase_counter = 0;
extern REAL imife_realtime_gain_off;

void PanGuMainISR(void){

    // 采样，包括DSP中的ADC采样等
    // DELAY_US(2); // wait for adc conversion TODO: check adc eoc flag?
    measurement();


    if(!Axis_1.FLAG_ENABLE_PWM_OUTPUT){

        DSP_PWM_DISABLE
        DSP_2PWM_DISABLE

        /* Only init once for easy debug */
        if(!G.flag_experimental_initialized){
            G.flag_experimental_initialized = TRUE;

            init_experiment();
            //init_experiment_AD_gain_and_offset();
            //init_experiment_overwrite();

            // TODO: use a function for this purpose!
            // 清空积分缓存
            PID_spd->OutPrev = 0;
            PID_iD->OutPrev = 0;
            PID_iQ->OutPrev = 0;
            // PID_iX->OutPrev = 0;
            // PID_iy->OutPrev = 0;

            EPwm1Regs.CMPA.bit.CMPA = 2500;
            EPwm2Regs.CMPA.bit.CMPA = 2500;
            EPwm3Regs.CMPA.bit.CMPA = 2500;
            EPwm4Regs.CMPA.bit.CMPA = 2500;
            EPwm5Regs.CMPA.bit.CMPA = 2500;
            EPwm6Regs.CMPA.bit.CMPA = 2500;

                //            CTRL_2.S->iD  = &_pid_iD_2;
                //            CTRL_2.S->iQ  = &_pid_iQ_2;
                //            CTRL_2.S->spd = &_pid_spd_2;
                //            CTRL_2.S->pos = &_pid_pos_2;

            if ((*CTRL).g->overwrite_vdc < 5){
                (*CTRL).g->overwrite_vdc = 28;
            }
            (*CTRL).g->flag_overwite_vdc = 0;
        }

        DELAY_US(5);
        GpioDataRegs.GPDCLEAR.bit.GPIO106=1; // TODO: What is this doing?

    }else{
        G.flag_experimental_initialized = FALSE;
        DSP_PWM_ENABLE
        DSP_2PWM_ENABLE
        if (FE.htz.u_offset[0] > 0.1){
            FE.htz.u_offset[0] = 0;
        }
        // DSP中控制器的时间
        (*CTRL).timebase_counter += 1;
        (*CTRL).timebase = CL_TS * (*CTRL).timebase_counter; //(*CTRL).timebase += CL_TS; // 2048 = float/REAL max

        // 根据指令，产生控制输出（电压）
        #if ENABLE_COMMISSIONING == FALSE
            //(*CTRL).S->Motor_or_Gnerator = sign((*CTRL).I->idq_cmd[1]) == sign(CTRL->enc->rpm); // sign((*CTRL).I->idq_cmd[1]) != sign((*CTRL).I->cmd_speed_rpm))
            runtime_command_and_tuning(Axis->Select_exp_operation);
            // 0x03 is shank
            //    position_count_CAN_fromCPU2 = position_count_CAN_ID0x03_fromCPU2;
            // 0x01 is hip
            position_count_CAN_fromCPU2 = position_count_CAN_ID0x01_fromCPU2;

            Axis->Set_manual_rpm = call_position_loop_controller(positionLoopType);

            Axis->used_theta_d_elec = controller(
                Axis->Set_manual_rpm,
                Axis->Set_current_loop,
                Axis->Set_manual_current_iq,
                Axis->Set_manual_current_id,
                Axis->flag_overwrite_theta_d,
                Axis->Overwrite_Current_Frequency,
                Axis->used_theta_d_elec,
                Axis->angle_shift_for_first_inverter,
                Axis->angle_shift_for_second_inverter);
        #else
            commissioning();
        #endif

            //(*CTRL).O->uab_cmd_to_inverter[0]

        if(Axis->Select_exp_operation == XCUBE_TaTbTc_DEBUG_MODE){
            if(axisCnt==0){
                EPwm1Regs.CMPA.bit.CMPA = (*CTRL).svgen1.Ta*50000000*CL_TS;
                EPwm2Regs.CMPA.bit.CMPA = (*CTRL).svgen1.Tb*50000000*CL_TS;
                EPwm3Regs.CMPA.bit.CMPA = (*CTRL).svgen1.Tc*50000000*CL_TS;
            }
            if(axisCnt==1){
                EPwm4Regs.CMPA.bit.CMPA = (*CTRL).svgen2.Ta*50000000*CL_TS;
                EPwm5Regs.CMPA.bit.CMPA = (*CTRL).svgen2.Tb*50000000*CL_TS;
                EPwm6Regs.CMPA.bit.CMPA = (*CTRL).svgen2.Tc*50000000*CL_TS;
            }
            // 20240119 test，观察4、5、6通道的IPM输出电压是否正常
            //            EPwm4Regs.CMPA.bit.CMPA = (*CTRL).svgen1.Ta*50000000*CL_TS;
            //            EPwm5Regs.CMPA.bit.CMPA = (*CTRL).svgen1.Tb*50000000*CL_TS;
            //            EPwm6Regs.CMPA.bit.CMPA = (*CTRL).svgen1.Tc*50000000*CL_TS;
        }
        else
            voltage_commands_to_pwm();
        //        #if NUMBER_OF_DSP_CORES == 1
        //            single_core_dac();
        //        #endif
    }
}

Uint64 EPWM1IntCount=0;
__interrupt void EPWM1ISR(void){
    EPWM1IntCount += 1;

#if USE_ECAP_CEVT2_INTERRUPT == 1
    CAP.password_isr_nesting = 178; // only if you can stop EPWM ISR, or else you won't know the value of password_isr_nesting.
    /* Step 1. [eCAP] Set the global priority */
    // Set global priority by adjusting IER, so as to allow PIE group 4 to send interrupt flag to CPU stage.
    IER |= M_INT4; // Modify IER to allow CPU interrupts from PIE group 4 to be serviced. Part 1
    IER &= M_INT4; // Modify IER to allow CPU interrupts from PIE group 4 to be serviced. Part 2

    /* Step 2. [eCAP] Set the group priority */
    uint16_t TempPIEIER4;
    TempPIEIER4 = PieCtrlRegs.PIEIER4.all; // Save PIEIER register for later
    PieCtrlRegs.PIEIER4.all &= 0x7;        // Set group priority by adjusting PIEIER4 to allow INT4.1, 4.2, 4.3 to interrupt current ISR

    /* Step 3. [eCAP] Enable interrupts */
    PieCtrlRegs.PIEACK.all = 0xFFFF;      // Enable PIE interrupts by writing all 1’s to the PIEACK register
    asm("       NOP");                    // Wait at least one cycle
    EINT;                                 // Enable global interrupts by clearing INTM
#endif

    /* Step 4. [ePWM] Execute EPWM ISR */
    // 只需要做一次的
    #if NUMBER_OF_DSP_CORES == 2
        write_DAC_buffer();
    #endif

    // 出厂底板，点灯代码
    //    static long int ii = 0;
    //    if(++ii%5000 == 0){
    //        //        EPwm1Regs.CMPA.bit.CMPA = (*CTRL).svgen1.Ta*50000000*CL_TS;
    //        //        EPwm2Regs.CMPA.bit.CMPA = (*CTRL).svgen1.Tb*50000000*CL_TS;
    //        //        EPwm3Regs.CMPA.bit.CMPA = (*CTRL).svgen1.Tc*50000000*CL_TS;
    //        //        EPwm4Regs.CMPA.bit.CMPA = (*CTRL).svgen2.Ta*50000000*CL_TS;
    //        //        EPwm5Regs.CMPA.bit.CMPA = (*CTRL).svgen2.Tb*50000000*CL_TS;
    //
    //        if(EPwm1Regs.CMPA.bit.CMPA==5000){
    //            EPwm1Regs.CMPA.bit.CMPA = 0;
    //        }else{
    //            EPwm1Regs.CMPA.bit.CMPA = 5000;
    //        }
    //    }
    //
    //    static long int jj = 0;
    //    if(++jj%10000 == 0){
    //        if(EPwm2Regs.CMPA.bit.CMPA==5000){
    //            EPwm2Regs.CMPA.bit.CMPA = 0;
    //        }else{
    //            EPwm2Regs.CMPA.bit.CMPA = 5000;
    //        }
    //    }
    //    return;

    #if ENABLE_ECAP
        do_enhanced_capture();
    #endif


    // read from CPU02
    #if NUMBER_OF_DSP_CORES == 2
        /* CPU02 (Remote) to CPU01 (Local)
        * The register to check is IPCSTS.
        * */
        counter_missing_position_measurement +=1;
        if(IPCRtoLFlagBusy(IPC_FLAG10) == 1) // if flag
        {
            max_counter_missing_position_measurement = counter_missing_position_measurement;
            counter_missing_position_measurement = 0;
            position_count_SCI_shank_fromCPU2 = Read.SCI_shank_position_count;
            position_count_SCI_hip_fromCPU2 = Read.SCI_hip_position_count;
            position_count_CAN_ID0x01_fromCPU2 = Read.CAN_position_count_ID0x01;
            position_count_CAN_ID0x03_fromCPU2 = Read.CAN_position_count_ID0x03;
            IPCRtoLFlagAcknowledge (IPC_FLAG10);

            // CAN encoder convert to motor built-in encoder
            deg_four_bar_map_motor_encoder_angle = get_motorpos(position_count_CAN_ID0x03_fromCPU2 * 0.00274658203125 ); //1/131072.0*360.0
            //deg_four_bar_map_motor_encoder_angle = lookup(position_count_CAN_ID0x03_fromCPU2 * 0.00274658203125, &ZJL_table);
            rad_four_bar_map_motor_encoder_angle = deg_four_bar_map_motor_encoder_angle * 0.017453292519943295;
            cnt_four_bar_map_motor_encoder_angle = deg_four_bar_map_motor_encoder_angle * 23301.68888888889;


            //这段放需要测时间的代码后面，观察CpuTimer_Delta的取值，代表经过了多少个 1/200e6 秒。
            #if PC_SIMULATION==FALSE
            CpuTimer_After = CpuTimer1.RegsAddr->TIM.all; // get count
            CpuTimer_Delta = (REAL)CpuTimer_Before - (REAL)CpuTimer_After;
            // EALLOW;
            // CpuTimer1.RegsAddr->TCR.bit.TSS = 1; // stop (not needed because of the line TRB=1)
            // EDIS;
            #endif

            //这段放需要测时间的代码前面
            #if PC_SIMULATION==FALSE
            EALLOW;
            CpuTimer1.RegsAddr->TCR.bit.TRB = 1; // reset cpu timer to period value
            CpuTimer1.RegsAddr->TCR.bit.TSS = 0; // start/restart
            CpuTimer_Before = CpuTimer1.RegsAddr->TIM.all; // get count
            EDIS;
            #endif
        }
        else
        {
            CPU2_commu_error_counter++;
        }
    #endif




    // 对每一个CTRL都需要做一次的代码
    if(use_first_set_three_phase==-1){
        for(axisCnt = 0; axisCnt < NUMBER_OF_AXES; axisCnt++){
            get_Axis_CTRL_pointers//(axisCnt, Axis, CTRL);
            PanGuMainISR();
        }axisCnt=1;
    }else if(use_first_set_three_phase==1){
        axisCnt = 0;
        get_Axis_CTRL_pointers//(axisCnt, Axis, CTRL);
        PanGuMainISR();
    }else if(use_first_set_three_phase==2){
        axisCnt = 1;
        get_Axis_CTRL_pointers//(axisCnt, Axis, CTRL);
        PanGuMainISR();
    }


#if USE_ECAP_CEVT2_INTERRUPT == 1
    /* Step 5. [eCAP] Disable interrupts */
    DINT;

    /* Step 6. [eCAP] Restore the PIEIERx register */
    PieCtrlRegs.PIEIER4.all = TempPIEIER4;
    CAP.password_isr_nesting = 0;
#endif

    /* Step 7. [ePWM] Exit EPWM1 ISR */
    EPwm1Regs.ETCLR.bit.INT = 1;
    PieCtrlRegs.PIEACK.all |= PIEACK_GROUP3;
}

#endif

/*
//声明全局变量
#if PC_SIMULATION==FALSE
REAL CpuTimer_Delta = 0;
Uint32 CpuTimer_Before = 0;
Uint32 CpuTimer_After = 0;
#endif


//这段放需要测时间的代码前面
#if PC_SIMULATION==FALSE
EALLOW;
CpuTimer1.RegsAddr->TCR.bit.TRB = 1; // reset cpu timer to period value
CpuTimer1.RegsAddr->TCR.bit.TSS = 0; // start/restart
CpuTimer_Before = CpuTimer1.RegsAddr->TIM.all; // get count
EDIS;
#endif

//这段放需要测时间的代码后面前面，观察CpuTimer_Delta的取值，代表经过了多少个 1/200e6 秒。
#if PC_SIMULATION==FALSE
CpuTimer_After = CpuTimer1.RegsAddr->TIM.all; // get count
CpuTimer_Delta = (REAL)CpuTimer_Before - (REAL)CpuTimer_After;
// EALLOW;
// CpuTimer1.RegsAddr->TCR.bit.TSS = 1; // stop (not needed because of the line TRB=1)
// EDIS;
#endif
*/
